#
# This file is part of gtkD.
# 
# gtkD is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version, with
# some exceptions, please read the COPYING file.
# 
# gtkD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with gtkD; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110, USA
#


#
###
#####
# Definitions for wrapping Gtk
#####
###
#

# must start with wrap



addTypedefs: start
public import gtkc.cairotypes;
public import gtkc.glibtypes;
public import gtkc.gobjecttypes;
public import gtkc.giotypes;
public import gtkc.pangotypes;
public import gtkc.atktypes;
public import gtkc.gdkpixbuftypes;
public import gtkc.gdktypes;

version(LDC)
{
	version(D_Version2)
	{
		extern(C) Object _d_newclass(ClassInfo ci);
	}
	else
	{
		extern (C) void* _d_allocclass(ClassInfo ci);
	}
}
else
{
	extern(C) Object _d_newclass(ClassInfo ci);
}

alias void GtkAccelGroupEntry;
alias void GtkContainerClass;

addTypedefs: end

addAliases: start
addAliases: end

addEnums: start
addEnums: end

addStructs: start

struct GtkObjectClass
{
	GObjectClass parentClass;
	void function(GtkObject*, GtkArg*, uint) setArg;
	void function(GtkObject*, GtkArg *, uint) getArg;
	void function(GtkObject*) destroy;
}

public struct GtkWidgetClass
{
	/* The object class structure needs to be the first
	 * element inn the widget class structure inn order for
	 * the class mechanism to work correctly. This allows a
	 * GtkWidgetClass pointer to be cast to a GtkObjectClass
	 * pointer.
	 */
	GtkObjectClass parentClass;
	/**/
	uint activateSignal;
	uint setScrollAdjustmentsSignal;
	/**/
	/* seldomly overidden */
	extern(C) void  function(GtkWidget *widget,uint nPspecs,GParamSpec **pspecs) dispatchChildPropertiesChanged;
	/* basics */
	extern(C) void  function(GtkWidget *widget)  show;
	extern(C) void  function(GtkWidget *widget)  showAll;
	extern(C) void  function(GtkWidget *widget)  hide;
	extern(C) void  function(GtkWidget *widget)  hideAll;
	extern(C) void  function(GtkWidget *widget)  map;
	extern(C) void  function(GtkWidget *widget)  unmap;
	extern(C) void  function(GtkWidget *widget)  realize;
	extern(C) void  function(GtkWidget *widget)  unrealize;
	extern(C) void  function(GtkWidget *widget,GtkRequisition *requisition)  sizeRequest;
	extern(C) void  function(GtkWidget *widget,GtkAllocation *allocation)  sizeAllocate;
	extern(C) void  function(GtkWidget *widget,GtkStateType previousState)  stateChanged;
	extern(C) void  function(GtkWidget *widget,GtkWidget *previousParent)  parentSet;
	extern(C) void  function(GtkWidget *widget,GtkWidget *previousToplevel)  hierarchyChanged;
	extern(C) void  function(GtkWidget *widget,GtkStyle *previousStyle)  styleSet;
	extern(C) void  function(GtkWidget *widget,GtkTextDirection previousDirection)  directionChanged;
	extern(C) void  function(GtkWidget *widget,int wasGrabbed)  grabNotify;
	extern(C) void  function(GtkWidget *widget,GParamSpec *pspec)  childNotify;
	/* Mnemonics */
	extern(C) int  function(GtkWidget *widget,int groupCycling)  mnemonicActivate;
	/* explicit focus */
	extern(C) void  function(GtkWidget *widget)  grabFocus;
	extern(C) int  function(GtkWidget *widget,GtkDirectionType direction)  focus;
	/* events */
	extern(C) int  function(GtkWidget *widget,GdkEvent *event)  event;
	extern(C) int  function(GtkWidget *widget,GdkEventButton *event)  buttonPressEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventButton *event)  buttonReleaseEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventScroll *event)  scrollEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventMotion *event)  motionNotifyEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventAny *event)  deleteEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventAny *event)  destroyEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventExpose *event)  exposeEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventKey *event)  keyPressEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventKey *event)  keyReleaseEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventCrossing *event)  enterNotifyEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventCrossing *event)  leaveNotifyEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventConfigure *event)  configureEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventFocus *event)  focusInEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventFocus *event)  focusOutEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventAny *event)  mapEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventAny *event)  unmapEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventProperty *event)  propertyNotifyEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventSelection *event)  selectionClearEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventSelection *event)  selectionRequestEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventSelection *event)  selectionNotifyEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventProximity *event)  proximityInEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventProximity *event)  proximityOutEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventVisibility *event)  visibilityNotifyEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventClient *event)  clientEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventAny *event)  noExposeEvent;
	extern(C) int  function(GtkWidget *widget,GdkEventWindowState *event)  windowStateEvent;
	/* selection */
	extern(C) void  function(GtkWidget *widget,GtkSelectionData *selectionData,uint info,uint time)  selectionGet;
	extern(C) void  function(GtkWidget *widget,GtkSelectionData *selectionData,uint time)  selectionReceived;
	/* Source side drag signals */
	extern(C) void  function(GtkWidget *widget,GdkDragContext *context)  dragBegin;
	extern(C) void  function(GtkWidget *widget,GdkDragContext *context)  dragEnd;
	extern(C) void  function(GtkWidget *widget,GdkDragContext *context,GtkSelectionData *selectionData,uint info,uint time)  dragDataGet;
	extern(C) void  function(GtkWidget *widget,GdkDragContext *context)  dragDataDelete;
	/* Target side drag signals */
	extern(C) void  function(GtkWidget *widget,GdkDragContext *context,uint time)  dragLeave;
	extern(C) int  function(GtkWidget *widget,GdkDragContext *context,int x,int y,uint time)  dragMotion;
	extern(C) int  function(GtkWidget *widget,GdkDragContext *context,int x,int y,uint time)  dragDrop;
	extern(C) void  function(GtkWidget *widget,GdkDragContext *context,int x,int y,GtkSelectionData *selectionData,uint info,uint time)  dragDataReceived;
	/* Signals used only for keybindings */
	extern(C) int  function(GtkWidget *widget)  popupMenu;
	/* If a widget has multiple tooltips/whatsthis, it should show the
	 * one for the current focus location, or if that doesn't make
	 * sense, should cycle through them showing each tip alongside
	 * whatever piece of the widget it applies to.
	*/
	extern(C) int  function(GtkWidget *widget,GtkWidgetHelpType helpType)  showHelp;
	/* accessibility support
	*/
	extern(C) AtkObject*  function(GtkWidget *widget) getAccessible;
	extern(C) void  function(GtkWidget *widget,GdkScreen *previousScreen) screenChanged;
	extern(C) int  function(GtkWidget *widget,uint signalId) canActivateAccel;
	/* Sent when a grab is broken. */
	extern(C) int  function(GtkWidget *widget,GdkEventGrabBroken *event) grabBrokenEvent;
	extern(C) void  function(GtkWidget *widget)  compositedChanged;
	extern(C) int  function(GtkWidget *widget,int x,int y,int keyboardTooltip,GtkTooltip *tooltip)  queryTooltip;
	/* Padding for future expansion */
	extern(C) void  function() _GtkReserved5;
	extern(C) void  function() _GtkReserved6;
	extern(C) void  function() _GtkReserved7;
}

struct GtkTextIter
{
	/* GtkTextIter is an opaque datatype; ignore all these fields.
	* Initialize the iter with gtk_text_buffer_get_iter_*
	* functions
	*/
	/*< private >*/
	gpointer dummy1;
	gpointer dummy2;
	gint dummy3;
	gint dummy4;
	gint dummy5;
	gint dummy6;
	gint dummy7;
	gint dummy8;
	gpointer dummy9;
	gpointer dummy10;
	gint dummy11;
	gint dummy12;
	/* padding */
	gint dummy13;
	gpointer dummy14;
}

addStructs: end

addTypes: start
addTypes: end

addFuncts: start
addFuncts: end

addUnions: start
addUnions: end

addConstants: start
addConstants: end



wrap: gtk

###########################################################
### Core Reference ########################################
###########################################################


file: gtk-General.html

#struct: 
class: Main
#prefix: 
prefix: gtk_main_
prefix: gtk_
noprefix: gtk_true
noprefix: gtk_false
noprefix: gtk_timeout_
noprefix: gtk_idle_
#import: g.OptionEntry
#structWrap: GOptionEntry* OptionEntry
import: glib.ErrorG
import: glib.GException
#import: g.OptionGroup
#structWrap: GOptionGroup* OptionGroup
import: gdk.Event
structWrap: GdkEvent* Event
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.ObjectGtk
structWrap: GtkObject* ObjectGtk
#import: gdk.ModifierType
#structWrap: GdkModifierType* ModifierType
import:  pango.PgLanguage
structWrap: PangoLanguage* PgLanguage
import: glib.Str
import: gtkc.gtk
import: gthread.Thread
import: gdk.Threads

inout: gtk_parse_args argv
array: gtk_parse_args argv argc
inout: gtk_init_check argv
array: gtk_init_check argv argc
inout: gtk_init_with_args argv
array: gtk_init_with_args argv argc
array: gtk_init_with_args entries
out: gtk_get_current_event_state state

alias: main run

code: start

	/**
	 * Call this function before using any other GTK+ functions in your GUI applications.
	 */
	public static void init(string[] args)
	{
		char** argv = (new char*[args.length]).ptr;
		int argc = 0;
		foreach (string p; args)
		{
			argv[argc++] = cast(char*)p;
		}
		
		init(&argc,&argv);
	}
	
	/**
	 * This initiates GtkD to supports multi threaded programs.
	 * read full documantation at http://gtk.org/faq/#AEN482
	 * from the FAQ:
	 * "There is a single global lock that you must acquire with 
	 * gdk_threads_enter() before making any GDK calls, 
	 * and release with gdk_threads_leave() afterwards throughout your code."
	 * This is to be used on any call to GDK not executed from the main thread.
	 */
	public static void initMultiThread(string[] args)
	{
		Thread.init(null);
		gdkThreadsInit();
		init(args);
	}
	
code: end
outFile: Main

class: Timeout
prefix: gtk_timeout_
strictPrefix: Y
code: start
	/** Holds all timeout delegates */
	bool delegate()[] timeoutListeners;
	/** our gtk timeout ID */
	uint timeoutID;

	 
	/**
	 * Creates a new timeout cycle.
	 * Params:
	 *    	interval = 	the timeout in milieconds
	 *    	delegate() = 	the delegate to be executed
	 *    	fireNow = 	When true the delegate will be executed emmidiatly
	 */
	this(uint interval, bool delegate() dlg, bool fireNow=false)
	{
		timeoutListeners ~= dlg;
		timeoutID = gtk_timeout_add(interval, cast(GtkFunction)&timeoutCallback, cast(void*)this);
		if ( fireNow )
		{
			if ( !dlg() )
			{
				timeoutListeners.length = 0;
			}
		}
	}

	/** */
	public void stop()
	{
		if ( timeoutID > 0 )
		{
			gtk_timeout_remove(timeoutID);
		}
		timeoutListeners.length = 0;
	}
	
	/**
	 * Removes the timeout from gtk
	 */
	~this()
	{
		stop();
	}
	
	/**
	 * Adds a new delegate to this timeout cycle
	 * Params:
	 *    	dlg = 	
	 *    	fireNow = 	
	 */
	public void addListener(bool delegate() dlg, bool fireNow=false)
	{
		timeoutListeners ~= dlg;
		if ( fireNow )
		{
			if ( !dlg() )
			{
				timeoutListeners.length = timeoutListeners.length - 1;
			}
		}
	}

	/**
	 * The callback execution from glib
	 * Params:
	 *    	timeout = 	
	 * Returns: 
	 */
	extern(C) static bool timeoutCallback(Timeout timeout)
	{
		return timeout.callAllListeners();
	}
	
	/**
	 * Executes all delegates on the execution list
	 * Returns: 
	 */
	private bool callAllListeners()
	{
		bool runAgain = false;
		
		int i = 0;
		
		while ( i<timeoutListeners.length )
		{
			if ( !timeoutListeners[i]() )
			{
				timeoutListeners = timeoutListeners[0..i] ~ timeoutListeners[i+1..timeoutListeners.length];
			}
			else
			{
				runAgain = true;
				++i;
			}
		}
		return runAgain;
	}
code: end
outFile: Timeout

class: Idle
prefix: gtk_idle_
strictPrefix: Y
code: start
	/** Holds all idle delegates */
	bool delegate()[] idleListeners;
	/** our gtk idle ID */
	uint idleID;

	/**
	 * Creates a new idle cycle.
	 * Params:
	 *    	interval = the idle in milieconds
	 *    	dlg = the delegate to be executed
	 *    	fireNow = When true the delegate will be executed emmidiatly
	 */
	this(bool delegate() dlg, bool fireNow=false)
	{
		idleListeners ~= dlg;
		idleID = gtk_idle_add(cast(GtkFunction)&idleCallback, cast(void*)this);
		if ( fireNow )
		{
			if ( !dlg() )
			{
				idleListeners.length = 0;
			}
		}
	}

	/** */
	public void stop()
	{
		if ( idleID > 0 )
		{
			gtk_idle_remove(idleID);
		}
		idleListeners.length = 0;
	}
	
	/**
	 * Removes the idle from gtk
	 */
	~this()
	{
		stop();
	}
	
	/**
	 * Adds a new delegate to this idle cycle
	 * Params:
	 *    	dlg = 	
	 *    	fireNow = 	
	 */
	public void addListener(bool delegate() dlg, bool fireNow=false)
	{
		idleListeners ~= dlg;
		if ( fireNow )
		{
			if ( !dlg() )
			{
				idleListeners.length = idleListeners.length - 1;
			}
		}
	}

	/**
	 * The callback execution from glib
	 * Params:
	 *    	idle = 	
	 * Returns: 
	 */
	extern(C) static bool idleCallback(Idle idle)
	{
		return idle.callAllListeners();
	}
	
	/**
	 * Executes all delegates on the execution list
	 * Returns: 
	 */
	private bool callAllListeners()
	{
		bool runAgain = false;
		
		int i = 0;
		
		while ( i<idleListeners.length )
		{
			if ( !idleListeners[i]() )
			{
				idleListeners = idleListeners[0..i] ~ idleListeners[i+1..idleListeners.length];
			}
			else
			{
				runAgain = true;
				++i;
			}
		}
		return runAgain;
	}
code: end
outFile: Idle


file: gtk-Keyboard-Accelerators.html
struct:  GtkAccelGroup
class: AccelGroup
prefix: gtk_accel_group_
prefix: gtk_
import: glib.Str
import: gobject.Closure
structWrap: GClosure* Closure
#import: gtk.AccelGroupEntry
#structWrap: GtkAccelGroupEntry* AccelGroupEntry
import: gobject.ObjectG
structWrap: GObject* ObjectG
import: gtk.AccelGroup
structWrap: GtkAccelGroup* AccelGroup
import: glib.ListSG
structWrap: GSList* ListSG
#import: gtk.AccelKey
#structWrap: GtkAccelKey* AccelKey
#import: gdk.ModifierType
#structWrap: GdkModifierType* ModifierType

array: gtk_accel_group_query Return n_entries
out: gtk_accelerator_parse accelerator_key
out: gtk_accelerator_parse accelerator_mods

outFile: AccelGroup

file: gtk-Accelerator-Maps.html
struct:  GtkAccelMap
class: AccelMap
prefix: gtk_accel_map_
prefix: gtk_
import: glib.Str
#import: gtk.AccelKey
#structWrap: GtkAccelKey* AccelKey
import: glib.ScannerG
structWrap: GScanner* ScannerG
import: gtk.AccelMap
structWrap: GtkAccelMap* AccelMap
out: gtk_accel_map_lookup_entry key
outFile: AccelMap

file: gtk-Clipboards.html
struct: GtkClipboard
class: Clipboard
prefix: gtk_clipboard_
prefix: gtk_
import: glib.Str
structWrap: GtkClipboard* Clipboard
import: gdk.Display
structWrap: GdkDisplay* Display
import: gtk.TextBuffer
structWrap: GtkTextBuffer* TextBuffer
import: gobject.ObjectG
structWrap: GObject* ObjectG
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
#import: gtk.SelectionData
#structWrap: GtkSelectionData* SelectionData

array: gtk_clipboard_set_with_data targets n_targets
array: gtk_clipboard_set_with_owner targets n_targets
out: gtk_clipboard_wait_for_rich_text format
array: gtk_clipboard_wait_for_rich_text Return length
out: gtk_clipboard_wait_for_targets targets
array: gtk_clipboard_wait_for_targets targets n_targets
array: gtk_clipboard_set_can_store targets n_targets

outFile: Clipboard

file: gtk-Drag-and-Drop.html
struct: GdkDragContext
class: DragAndDrop
prefix: gtk_drag_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
#import: gtk.TargetEntry
#structWrap: GtkTargetEntry* TargetEntry
import: gdk.Window
structWrap: GdkWindow* Window
import: gdk.DragContext
structWrap: GdkDragContext* DragContext
import: gtk.TargetList
structWrap: GtkTargetList* TargetList
import: gdk.Event
structWrap: GdkEvent* Event
import: gdk.Colormap
structWrap: GdkColormap* Colormap
import: gdk.Pixmap
structWrap: GdkPixmap* Pixmap
import: gdk.Bitmap
structWrap: GdkBitmap* Bitmap
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
outFile: DragAndDrop

array: gtk_drag_dest_set targets n_targets
array: gtk_drag_source_set targets n_targets

file: GtkIconTheme.html

struct: GtkIconTheme
class: IconTheme
prefix: gtk_icon_theme_
noprefix: gtk_icon_info_
prefix: gtk_
import: glib.Str
import: gio.IconIF
structWrap: GIcon* IconIF
structWrap: GtkIconTheme* IconTheme
import: gdk.Screen
structWrap: GdkScreen* Screen
import: gtk.IconInfo
structWrap: GtkIconInfo* IconInfo
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: glib.ErrorG
import: glib.GException
import: glib.ListG
structWrap: GList* ListG

array: gtk_icon_theme_set_search_path path n_elements
out: gtk_icon_theme_get_search_path path
array: gtk_icon_theme_get_search_path path n_elements
array: gtk_icon_theme_choose_icon icon_names
outFile: IconTheme

struct: GtkIconInfo
class: IconInfo
prefix: gtk_icon_info_
strictPrefix: Y
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gtk.IconInfo
structWrap: GtkIconInfo* IconInfo
import: gtk.IconTheme
structWrap: GtkIconTheme* IconTheme
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf

out: gtk_icon_info_get_embedded_rect rectangle
out: gtk_icon_info_get_attach_points points
array: gtk_icon_info_get_attach_points points n_points

outFile: IconInfo

file: gtk-Stock-Items.html
struct: GtkStockItem
class: StockItem
prefix: gtk_stock_
prefix: gtk_
import: glib.Str
import: gtk.StockItem
structWrap: GtkStockItem* StockItem
import: glib.ListSG
structWrap: GSList* ListSG
outFile: StockItem

file: gtk-Themeable-Stock-Images.html
struct: GtkIconSource
class: IconSource
prefix: gtk_icon_source_
#prefix: gtk_
noprefix: gtk_icon_factory_
noprefix: gtk_icon_set_
noprefix: gtk_icon_size_

import: glib.Str
structWrap: GtkIconSource* IconSource
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
outFile: IconSource

struct: GtkIconFactory
class: IconFactory
prefix: gtk_icon_factory_
strictPrefix: Y
import: glib.Str
structWrap: GtkIconFactory* IconFactory
import: gtk.IconSet
structWrap: GtkIconSet* IconSet
outFile: IconFactory

struct: GtkIconSet
class: IconSet
prefix: gtk_icon_set_
strictPrefix: Y
import: glib.Str
structWrap: GtkIconSet* IconSet
import: gtk.IconSource
structWrap: GtkIconSource* IconSource
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.Style
structWrap: GtkStyle* Style
import: gtk.Widget
structWrap: GtkWidget* Widget
out: gtk_icon_set_get_sizes sizes
array: gtk_icon_set_get_sizes sizes n_sizes
outFile: IconSet

class: IconSize
prefix: gtk_icon_size_
strictPrefix: Y
import: glib.Str
import: gtk.Settings
structWrap: GtkSettings* Settings

out: gtk_icon_size_lookup width
out: gtk_icon_size_lookup height
out: gtk_icon_size_lookup_for_settings width
out: gtk_icon_size_lookup_for_settings height

outFile: IconSize

file: gtk-Resource-Files.html
struct: GtkRcStyle
class: RcStyle
prefix: gtk_rc_
prefix: gtk_
import: glib.ScannerG
structWrap: GScanner* ScannerG
import: glib.Str
import: gtk.Style
structWrap: GtkStyle* Style
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Settings
structWrap: GtkSettings* Settings
import: gdk.Color
structWrap: GdkColor* Color
#import: gtk.StateType
#structWrap: GtkStateType* StateType
#import: gtk.PathPriorityType
#structWrap: GtkPathPriorityType* PathPriorityType
structWrap: GtkRcStyle* RcStyle

array: gtk_rc_set_default_files filenames
out: gtk_rc_parse_state state
out: gtk_rc_parse_priority priority

outFile: RcStyle

file: GtkSettings.html
struct: GtkSettings
class: Settings
prefix: gtk_settings_
prefix: gtk_
import: glib.Str
import: gtk.Settings
structWrap: GtkSettings* Settings
import: gdk.Screen
structWrap: GdkScreen* Screen
import: gobject.ParamSpec
structWrap: GParamSpec* ParamSpec
import: glib.StringG
structWrap: GString* StringG
import: gobject.Value
structWrap: GValue* Value
#import: gtk.SettingsValue
#structWrap: GtkSettingsValue* SettingsValue
outFile: Settings

file: gtk-Bindings.html
struct: GtkBindingSet
class: BindingSet
prefix: gtk_binding_set_
prefix: gtk_bindings_
prefix: gtk_
import: glib.Str
import: gtk.BindingSet
structWrap: GtkBindingSet* BindingSet
import: gtk.ObjectGtk
structWrap: GtkObject* ObjectGtk
#import: gdk.EventKey
#structWrap: GdkEventKey* EventKey
import: glib.ListSG
structWrap: GSList* ListSG
import: glib.ScannerG
structWrap: GScanner* ScannerG
outFile: BindingSet

file: gtk-Standard-Enumerations.html
#struct: 
class: StandardEnumerations
#prefix: 
#prefix: gtk_
outFile: StandardEnumerations

file: gtk-Graphics-Contexts.html
#struct: 
class: GCs
prefix: gtk_gc_
prefix: gtk_
import: gdk.GC
structWrap: GdkGC* GC
import: gdk.Colormap
structWrap: GdkColormap* Colormap
#import: gdk.GCValues
#structWrap: GdkGCValues* GCValues
outFile: GCs

file: GtkStyle.html
struct: GtkStyle
class: Style
prefix: gtk_style_
prefix: gtk_
noprefix: gtk_border_
import: glib.Str
structWrap: GtkStyle* Style
import: gdk.Color
structWrap: GdkColor* Color
import: gdk.Window
structWrap: GdkWindow* Window
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
import: gtk.IconSet
structWrap: GtkIconSet* IconSet
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.IconSource
structWrap: GtkIconSource* IconSource
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gdk.Font
structWrap: GdkFont* Font
import: gdk.Drawable
structWrap: GdkDrawable* Drawable
import: gobject.Value
structWrap: GValue* Value
import: pango.PgLayout
structWrap: PangoLayout* PgLayout
nocode: gtk_style_ref
nocode: gtk_style_unref

array: gtk_draw_polygon points npoints
array: gtk_paint_polygon points npoints

outFile: Style

struct: GtkBorder
class: Border
prefix: gtk_border_
structWrap: GtkBorder* Border
strictPrefix: Y
outFile: Border

file: gtk-Selections.html
struct: GtkTargetList
class: TargetList
prefix: gtk_target_list_
noprefix: gtk_selection_
#import: gdk.Atom
#structWrap: GdkAtom* Atom
import: gtk.TextBuffer
structWrap: GtkTextBuffer* TextBuffer
structWrap: GtkTargetList* TargetList

array: gtk_target_list_new targets ntargets
array: gtk_target_list_add_table targets ntargets
out: gtk_target_list_find info
array: gtk_target_table_free targets ntargets
array: gtk_target_table_new_from_list Return n_targets
array: gtk_targets_include_image targets n_targets
array: gtk_targets_include_text targets n_targets
array: gtk_targets_include_uri targets n_targets
array: gtk_targets_include_rich_text targets n_targets

outFile: TargetList

#struct: 
class: Selections
prefix: gtk_selection_
strictPrefix: Y
import: glib.Str
import: gdk.Display
structWrap: GdkDisplay* Display
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gdk.Display
structWrap: GdkDisplay* Display
#import: gtk.SelectionData
#structWrap: GtkSelectionData* SelectionData
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.TextBuffer
structWrap: GtkTextBuffer* TextBuffer

array: gtk_selection_add_targets targets ntargets
array: gtk_selection_data_set data length
array: gtk_selection_data_set_uris uris
out: gtk_selection_data_get_targets targets
array: gtk_selection_data_get_targets targets n_atoms

outFile: Selections

file: gtk-Feature-Test-Macros.html
#struct: 
class: Version
prefix: gtk_
import: glib.Str
import: gtkc.Loader
import: gtkc.paths

code: start
	/*
	 * The major version number of the GTK+ library. (e.g. in GTK+ version 2.12.4 this is 2.)
	 * This variable is in the library, so represents the GTK+ library you have linked against. 
	 */
	public static int major()
	{
		uint* vers;
		
		Linker.link(vers, "gtk_major_version", LIBRARY.GTK);
		
		if ( vers is null )
		{
			return -1;
		}
		else
		{
			return *vers;
		}
	}

	/*
	 * The minor version number of the GTK+ library. (e.g. in GTK+ version 2.12.4 this is 12.) 
	 * This variable is in the library, so represents the GTK+ library you have linked against. 
	 */
	public static int minor()
	{
		uint* vers;
		
		Linker.link(vers, "gtk_minor_version", LIBRARY.GTK);
		
		if ( vers is null )
		{
			return -1;
		}
		else
		{
			return *vers;
		}
	}

	/*
	 * The micro version number of the GTK+ library. (e.g. in GTK+ version 2.12.4 this is 4.) 
	 * This variable is in the library, so represents the GTK+ library you have linked against. 
	 */
	public static int micro()
	{
		uint* vers;
		
		Linker.link(vers, "gtk_micro_version", LIBRARY.GTK);
		
		if ( vers is null )
		{
			return -1;
		}
		else
		{
			return *vers;
		}
	}
code: end
outFile: Version

file: gtk-Signals.html
#struct: 
class: Signals
prefix: gtk_signal_
prefix: gtk_
import: glib.Str
#import: gtk.Type
#structWrap: GtkType* Type
import: gtk.ObjectGtk
structWrap: GtkObject* ObjectGtk
#import: gtk.Arg
#structWrap: GtkArg* Arg

array: gtk_signal_newv args n_args
array: gtk_signal_emitv args
array: gtk_signal_emitv_by_name args

outFile: Signals

file: gtk-Types.html
struct: GtkType
class: Types
prefix: gtk_type_
prefix: gtk_
import: glib.Str
#import: gtk.TypeInfo
#structWrap: GtkTypeInfo* TypeInfo
#import: gtk.EnumValue
#structWrap: GtkEnumValue* EnumValue
#import: gtk.FlagValue
#structWrap: GtkFlagValue* FlagValue
outFile: Types

file: gtk-Testing.html
class: Testing
prefix: gtk_test_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.SpinButton
structWrap: GtkSpinButton* SpinButton

code: start
	/**
	 * This function is used to initialize a GTK+ test program.
	 * It will in turn call g_test_init() and gtk_init() to
	 * properly initialize the testing framework and graphical toolkit.
	 * It'll also set the program's locale to "C" and prevent loading of
	 * rc files and Gtk+ modules. This is done to make tets program environments as deterministic as possible.
	 * Like gtk_init() and g_test_init(), any known arguments will be processed and stripped from argc and argv.
	 * Params:
	 *  argvp = Address of the argv parameter of main(). Any parameters understood by g_test_init() or gtk_init() are stripped before return. 
	 */
	public static void testInit(ref string[] argv)
	{
		// void gtk_test_init(int *argcp, char ***argvp, ...);
		char** outargv = Str.toStringzArray(argv);
		int argc = cast(int) argv.length;
		
		gtk_test_init(&argc, &outargv, null);
		
		argv = Str.toStringArray(outargv);
	}
code: end
outFile: Testing

file: gtk-Filesystem-utilities.html
struct: GtkMountOperation
ctorStruct: GMountOperation
class: MountOperation
extend: GioMountOperation
prefix: gtk_mount_operation_
prefix: gtk_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gtk.Window
structWrap: GtkWindow* Window
import: gdk.Screen
structWrap: GdkScreen* Screen
import: gio.MountOperation : GioMountOperation = MountOperation
outFile: MountOperation

###########################################################
### Windows ###############################################
###########################################################

file: GtkDialog.html
struct: GtkDialog
class: Dialog
prefix: gtk_dialog_
prefix: gtk_
import: glib.Str
import: gtk.Window
structWrap: GtkWindow* Window
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gdk.Screen
structWrap: GdkScreen* Screen
import: gtk.HButtonBox
import: gtk.VBox

array: gtk_dialog_set_alternative_button_order_from_array new_order n_params

# Make these return the correct class.
nocode: gtk_dialog_get_action_area
nocode: gtk_dialog_get_content_area

code: start
	/**
	 * Both title and parent can be null.
	 */
	this(string title, Window parent, GtkDialogFlags flags, string[] buttonsText, ResponseType[] responses)
	{
		auto p = gtk_dialog_new_with_buttons(Str.toStringz(title), (parent is null) ? null : parent.getWindowStruct(), flags, Str.toStringz(buttonsText[0]), responses[0], null);
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_dialog_new_with_buttons");
		}
		
		this(cast(GtkDialog*)p);
		
		addButtons(buttonsText[1 .. $], responses[1 .. $]);
	}
	
	/** ditto */
	this(string title, Window parent, GtkDialogFlags flags, StockID[] stockIDs, ResponseType[] responses)
	{
		auto p = gtk_dialog_new_with_buttons(Str.toStringz(title), (parent is null) ? null : parent.getWindowStruct(), flags, Str.toStringz(StockDesc[stockIDs[0]]), responses[0], null);
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_dialog_new_with_buttons");
		}
		
		this(cast(GtkDialog*)p);
		
		addButtons(stockIDs[1 .. $], responses[1 .. $]);
	}

	/** */
	public Widget addButton(StockID stockID, int responseId)
	{
		return addButton(StockDesc[stockID], responseId);
	}
	
	/** */
	public void addButtons(string[] buttonsText, ResponseType[] responses)
	{
		for ( int i=0 ; i<buttonsText.length && i<responses.length ; i++)
		{
			addButton(buttonsText[i], responses[i]);
		}
	}
	
	/** */
	public void addButtons(StockID[] stockIDs, ResponseType[] responses)
	{
		for ( int i=0 ; i<stockIDs.length && i<responses.length ; i++)
		{
			addButton(stockIDs[i], responses[i]);
		}
	}

	//Return the corect class instead of Widget
	/**
	 * Returns the action area of dialog.
	 * Since 2.14
	 * Returns: the action area.
	 */
	public HButtonBox getActionArea()
	{
		// GtkWidget* gtk_dialog_get_action_area (GtkDialog *dialog);
		auto p = gtk_dialog_get_action_area(gtkDialog);
		if(p is null)
		{
			return null;
		}
		return new HButtonBox(cast(GtkHButtonBox*) p);
	}
	
	//Return the corect class instead of Widget
	/**
	 * Returns the content area of dialog.
	 * Since 2.14
	 * Returns: the content area GtkVBox.
	 */
	public VBox getContentArea()
	{
		// GtkWidget* gtk_dialog_get_content_area (GtkDialog *dialog);
		auto p = gtk_dialog_get_content_area(gtkDialog);
		if(p is null)
		{
			return null;
		}
		return new VBox(cast(GtkVBox*) p);
	}
code: end
outFile: Dialog

file: GtkInvisible.html
struct: GtkInvisible
class: Invisible
prefix: gtk_invisible_
prefix: gtk_
import: gdk.Screen
structWrap: GdkScreen* Screen

override: getScreen

outFile: Invisible

file: GtkMessageDialog.html
struct: GtkMessageDialog
class: MessageDialog
prefix: gtk_message_dialog_
prefix: gtk_
import: glib.Str
import: gtk.VBox
import: gtk.Window
structWrap: GtkWindow* Window
import: gtk.Widget
structWrap: GtkWidget* Widget

nocode: gtk_message_dialog_new
nocode: gtk_message_dialog_new_with_markup
nocode: gtk_message_dialog_get_message_area

code: start
	/**
	 * Creates a new message dialog, which is a simple dialog with an icon
	 * indicating the dialog type (error, warning, etc.) and some text the
	 * user may want to see. When the user clicks a button a "response"
	 * signal is emitted with response IDs from GtkResponseType. See
	 * GtkDialog for more details.
	 * Params:
	 *    	parent = transient parent, or NULL for none
	 *    	flags = flags
	 *    	type = type of message
	 *    	buttons= set of buttons to use
	 *    	messageFormat = printf()-style format string, or NULL
	 *    	message = the message - should be null, any formatting should be done prior to call this constructor
	 *  arguments for message_format
	 * Returns:
	 *  a new GtkMessageDialog
	 */
	public this (Window parent, GtkDialogFlags flags, GtkMessageType type, GtkButtonsType buttons, string messageFormat, string message=null )
	{
		this(parent, flags, type, buttons, false, messageFormat, message );
	}
	
	/**
	 * Creates a new message dialog, which is a simple dialog with an icon
	 * indicating the dialog type (error, warning, etc.) and some text which
	 * is marked up with the Pango text markup language.
	 * When the user clicks a button a "response" signal is emitted with
	 * response IDs from GtkResponseType. See GtkDialog for more details.
	 * 
	 * If Markup is true special XML characters in the printf() arguments passed to this
	 * function will automatically be escaped as necessary.
	 * (See g_markup_printf_escaped() for how this is implemented.)
	 * Usually this is what you want, but if you have an existing
	 * Pango markup string that you want to use literally as the
	 * label, then you need to use gtk_message_dialog_set_markup()
	 * instead, since you can't pass the markup string either
	 * as the format (it might contain '%' characters) or as a string
	 * argument.
	 * Since 2.4
	 * Examples:
	 * --------------------
	 *  GtkWidget *dialog;
	 *  dialog = gtk_message_dialog_new (main_application_window,
	 *  GTK_DIALOG_DESTROY_WITH_PARENT,
	 *  GTK_MESSAGE_ERROR,
	 *  GTK_BUTTONS_CLOSE,
	 *  NULL);
	 *  gtk_message_dialog_set_markup (GTK_MESSAGE_DIALOG (dialog),
	 *  markup);
	 * --------------------
	 * Params:
	 *  parent = transient parent, or NULL for none
	 *  flags = flags
	 *  type = type of message
	 *  buttons = set of buttons to use
	 *  messageFormat = printf()-style format string, or NULL
	 *  message = the message - should be null, any formatting should be done prior to call this constructor
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (Window parent, GtkDialogFlags flags, GtkMessageType type, GtkButtonsType buttons, bool markup, string messageFormat, string message=null )
	{
		GtkMessageDialog* p;

		if ( markup )
		{
			// GtkWidget* gtk_message_dialog_new_with_markup  (GtkWindow *parent,  GtkDialogFlags flags,  GtkMessageType type,  GtkButtonsType buttons,  const gchar *message_format,  ...);
			p = cast(GtkMessageDialog*)gtk_message_dialog_new_with_markup(
					parent is null ? null : parent.getWindowStruct(), 
					flags, 
					type, 
					buttons, 
					Str.toStringz(messageFormat),
					Str.toStringz(message),	// this should be null
					null
				);
		}
		else
		{
			// GtkWidget* gtk_message_dialog_new (GtkWindow *parent,  GtkDialogFlags flags,  GtkMessageType type,  GtkButtonsType buttons,  const gchar *message_format,  ...);
			p = cast(GtkMessageDialog*)gtk_message_dialog_new(
					parent is null ? null : parent.getWindowStruct(), 
					flags, 
					type, 
					buttons, 
					Str.toStringz(messageFormat),
					Str.toStringz(message),	// this should be null
					null
				);
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_button_new()");
		}

		this(p);
	}

	/**
	 * Since 2.22
	 * Returns: A GtkVBox corresponding to the "message area" in the message_dialog. This is the box where the dialog's primary and secondary labels are packed. You can add your own extra content to that box and it will appear below those labels, on the right side of the dialog's image (or on the left for right-to-left languages). See gtk_dialog_get_content_area() for the corresponding function in the parent GtkDialog.
	 */
	public VBox getMessageArea()
	{
		// GtkWidget * gtk_message_dialog_get_message_area (GtkMessageDialog *message_dialog);
		auto p = gtk_message_dialog_get_message_area(gtkMessageDialog);
		if(p is null)
		{
			return null;
		}
		return new VBox(cast(GtkVBox*) p);
	}
code: end

outFile: MessageDialog

file: 
class: PopupBox
import: gtk.MessageDialog;
import: gtk.Window;

code: start
	/**
	 * Create an information popup dialog.
	 * Params:
	 *  message = The message to show on the dialog
	 *  title = The title of the dialog
	 */
	public static void information(string message, string title)
	{
		information(null, message, title);
	}
	
	/**
	 * Create an information popup dialog.
	 * Params:
	 *  parent = The parent window of this popup dialog
	 *  message = The message to show on the dialog
	 *  title = The title of the dialog
	 */
	public static void information(Window parent, string message, string title)
	{
		MessageDialog d = new MessageDialog(parent, cast(GtkDialogFlags)0,
										MessageType.INFO,
										ButtonsType.OK ,
										message);
		d.setTitle(title);
		//d.addButton("gtk-dialog-info",GtkResponseType.OK);
		d.run();
		d.destroy();
	}
	
	
	/**
	 * Create an error popup dialog.
	 * Params:
	 *  message = The message to show on the dialog
	 *  title = The title of the dialog
	 */
	public static void error(string message, string title)
	{
		error(null, message, title);
	}
	
	/**
	 * Create an error popup dialog.
	 * Params:
	 *  parent = The parent window of this popup dialog
	 *  message = The message to show on the dialog
	 *  title = The title of the dialog
	 */
	public static void error(Window parent, string message, string title)
	{
		MessageDialog d = new MessageDialog(parent, cast(GtkDialogFlags)0,
										MessageType.ERROR,
										ButtonsType.CANCEL ,
										message);
		d.setTitle(title);
		//d.addButton("gtk-dialog-error",ResponseType.CANCEL);
		d.run();
		d.destroy();
	}
	
	
	
	/**
	 * Create an 'yes' or 'no' popup dialog.
	 * Params:
	 *  message = The message to show on the dialog
	 *  title = The title of the dialog
	 */
	public static bool yesNo(string message, string title)
	{
		return yesNo(null, message, title);
	}
	
	/**
	 * Create an 'yes' or 'no' popup dialog.
	 * Params:
	 *  parent = The parent window of this popup dialog
	 *  message = The message to show on the dialog
	 *  title = The title of the dialog
	 */
	public static bool yesNo(Window parent, string message, string title)
	{
		MessageDialog d = new MessageDialog(
				parent, cast(GtkDialogFlags)0,
				MessageType.QUESTION,
				ButtonsType.NONE ,
				message);
		d.setTitle(title);
		d.addButton("gtk-no",ResponseType.NO);
		d.addButton("gtk-yes",ResponseType.YES);
		int responce = d.run();
		d.destroy();
		return responce == ResponseType.YES;
	}

	
	/**
	 * Create an 'yes', 'no' or 'cancel' popup dialog.
	 * Params:
	 *  message = The message to show on the dialog
	 *  title = The title of the dialog
	 */
	public static ResponseType yesNoCancel(string message, string title)
	{
		return yesNoCancel(null, message, title);
	}
	
	/**
	 * Create an 'yes', 'no' or 'cancel' popup dialog.
	 * Params:
	 *  parent = The parent window of this popup dialog
	 *  message = The message to show on the dialog
	 *  title = The title of the dialog
	 */
	public static ResponseType yesNoCancel(Window parent, string message, string title)
	{
		MessageDialog d = new MessageDialog(
				parent, cast(GtkDialogFlags)0,
				MessageType.QUESTION,
				ButtonsType.NONE ,
				message);
		d.setTitle(title);
		d.addButton("gtk-no",ResponseType.NO);
		d.addButton("gtk-yes",ResponseType.YES);
		d.addButton("gtk-cancel",ResponseType.CANCEL);
		ResponseType responce = cast(ResponseType)d.run();
		d.destroy();
		return responce;
	}
code: end
outFile: PopupBox

file: GtkWindow.html
struct: GtkWindow
class: Window
prefix: gtk_window_
prefix: gtk_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gtk.AccelGroup
structWrap: GtkAccelGroup* AccelGroup
import: gtk.Widget
structWrap: GtkWidget* Widget
#import: gdk.Geometry
#structWrap: GdkGeometry* Geometry
structWrap: GtkWindow* Window
import: gtk.WindowGroup
structWrap: GtkWindowGroup* WindowGroup
import: gdk.Screen
structWrap: GdkScreen* Screen
import: glib.ListG
structWrap: GList* ListG
#import: gdk.EventKey
#structWrap: GdkEventKey* EventKey
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf

override: getScreen

out: gtk_window_get_size width
out: gtk_window_get_size height
out: gtk_window_get_default_size width
out: gtk_window_get_default_size height
out: gtk_window_get_frame_dimensions left
out: gtk_window_get_frame_dimensions top
out: gtk_window_get_frame_dimensions right
out: gtk_window_get_frame_dimensions bottom
out: gtk_window_get_position root_x
out: gtk_window_get_position root_y

code: start
	/**
	 * Creates a top level window with a title
	 * Params:
	 * 		title = The Window title
	 */
	public this(string title)
	{
		this(GtkWindowType.TOPLEVEL);
		setTitle(title);
	}

	/**
	 * Move the window to an absolute position.
	 * just calls move(int, int).
	 * convinience because GdkEvent structs return the position coords as doubles
	 */
	public void move(double x, double y)
	{
		move(cast(int)x, cast(int)y);
	}
code: end
text: start
gtk_window_set_default_icon_from_file ()
gboolean gtk_window_set_default_icon_from_file  (const gchar *filename,  GError **err);
Sets an icon to be used as fallback for windows that haven't
had gtk_window_set_icon_list() called on them from a file
on disk. Warns on failure if err is NULL.
Since 2.2
filename :
location of icon file
Returns :
TRUE if setting the icon succeeded.
<hr>
gtk_window_set_icon_from_file()
gboolean gtk_window_set_icon_from_file (GtkWindow *window,  const gchar *filename,  GError **err);
Sets the icon for window.
Warns on failure if err is NULL.
This function is equivalent to calling gtk_window_set_icon()
with a pixbuf created by loading the image from filename.
Since 2.2
filename :
location of icon file
Returns :
TRUE if setting the icon succeeded.
text: end
outFile: Window

file: 
import: gtk.Widget
import: gtk.Window
import: gtk.Main
import: gdk.Event
	

code: start

/**
 * A top Level window that will stop the main event cycle when it's closed.
 * Closing the last of the windows of class "MainWindow" will end the application.
 */
public class MainWindow : Window
{

	private static int countTotalMainWindows = 0;

	/**
	 * Creates a new MainWindow with a title
	 */
	public this(string title)
	{
		super(title);
		countTotalMainWindows++;
		//printf("MainWindows.this count = %d\n", countTotalMainWindows);
		addOnDelete(&windowDelete);
	}
	
	/**
	 * Executed when the user tries to close the window
	 * Returns: true to refuse to close the window
	 */
	protected bool windowDelete(Event event, Widget widget)
	{
		--countTotalMainWindows;
		//printf("MainWindows.windowDelete count = %d\n", countTotalMainWindows);
		if ( exit(0, false) || countTotalMainWindows==0 )
		{
			Main.quit();
			return false;
		}
		return false;
	}
	
	/**
	 * Allows the application to close and decide if it can exit
	 * Params:
	 *  code = the code reason to exit
	 *  force = if true the application must expect to be closed even against it's will
	 * Returns: false to refuse to exit
	 */
	protected bool exit(int code, bool force)
	{
		return force;
	}
}

code: end
outFile: MainWindow

file: GtkWindowGroup.html
struct: GtkWindowGroup
class: WindowGroup
prefix: gtk_window_group_
prefix: gtk_
import: glib.ListG
structWrap: GList* ListG
import: gtk.Window
structWrap: GtkWindow* Window
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: WindowGroup

file: GtkAboutDialog.html
struct: GtkAboutDialog
class: AboutDialog
prefix: gtk_about_dialog_
prefix: gtk_
import: glib.Str
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.Window
structWrap: GtkWindow* Window

override: getName
override: setName

array: gtk_about_dialog_set_authors authors
array: gtk_about_dialog_set_artists artists
array: gtk_about_dialog_set_documenters documenters

outFile: AboutDialog

file: GtkAssistant.html
struct: GtkAssistant
class: Assistant
prefix: gtk_assistant_
prefix: gtk_
import: glib.Str
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: Assistant

file: GtkOffscreenWindow.html
struct: GtkOffscreenWindow
class: OffscreenWindow
prefix: gtk_offscreen_window_
import: gdk.Pixmap
structWrap: GdkPixmap* Pixmap
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: OffscreenWindow

###########################################################
### Display Widgets #######################################
###########################################################

file: GtkAccelLabel.html
struct: GtkAccelLabel
class: AccelLabel
prefix: gtk_accel_label_
prefix: gtk_
import: glib.Str
import: gobject.Closure
structWrap: GClosure* Closure
import: gtk.Widget
structWrap: GtkWidget* Widget
import: pango.PgAttributeList
structWrap: PangoAttrList* PgAttributeList
import: pango.PgLayout
structWrap: PangoLayout* PgLayout
outFile: AccelLabel

file: GtkImage.html
struct: GtkImage
class: Image
prefix: gtk_image_
prefix: gtk_
import: glib.Str
import: gio.Icon
import: gio.IconIF
structWrap: GIcon* IconIF
import: gtk.IconSet
structWrap: GtkIconSet* IconSet
import: gdk.ImageGdk
structWrap: GdkImage* ImageGdk
import: gdk.Bitmap
structWrap: GdkBitmap* Bitmap
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gdk.Pixmap
structWrap: GdkPixmap* Pixmap
import: gdkpixbuf.PixbufAnimation
structWrap: GdkPixbufAnimation* PixbufAnimation
import: gtk.IconSet
structWrap: GtkIconSet* IconSet
import: gdk.ImageGdk
structWrap: GdkImage* ImageGdk
import: gdk.Bitmap
structWrap: GdkBitmap* Bitmap
import: gdk.Pixmap
structWrap: GdkPixmap* Pixmap

out: gtk_image_get_icon_set icon_set
out: gtk_image_get_icon_set size
out: gtk_image_get_image gdk_image
out: gtk_image_get_image mask
out: gtk_image_get_pixmap pixmap
out: gtk_image_get_pixmap mask
out: gtk_image_get_stock stock_id
out: gtk_image_get_stock size
out: gtk_image_get_icon_name icon_name
out: gtk_image_get_icon_name size
out: gtk_image_get_gicon gicon
out: gtk_image_get_gicon size
out: gtk_image_get val
out: gtk_image_get mask

nocode: gtk_image_new_from_stock
nocode: gtk_image_new_from_icon_name

code: start
// this will be an enum 
	/**
	 * Creates a GtkImage displaying a stock icon. Sample stock icon
	 * names are GTK_STOCK_OPEN, GTK_STOCK_EXIT. Sample stock sizes
	 * are GTK_ICON_SIZE_MENU, GTK_ICON_SIZE_SMALL_TOOLBAR. If the stock
	 * icon name isn't known, the image will be empty.
	 * You can register your own stock icon names, see
	 * gtk_icon_factory_add_default() and gtk_icon_factory_add().
	 * Params:
	 *  StockID = a stock icon name
	 *  size = a stock icon size
	 * Returns:
	 *  a new GtkImage displaying the stock icon
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (StockID stockID, GtkIconSize size)
	{
		// GtkWidget* gtk_image_new_from_stock (const gchar *stock_id,  GtkIconSize size);
		auto p = gtk_image_new_from_stock(Str.toStringz(StockDesc[stockID]), size);
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_image_new_from_stock(Str.toStringz(StockDesc[stockID]), size)");
		}
		this(cast(GtkImage*)p);
	}
	
	/**
	 * Creates a GtkImage displaying an icon from the current icon theme.
	 * If the icon name isn't known, a "broken image" icon will be
	 * displayed instead. If the current icon theme is changed, the icon
	 * will be updated appropriately. Since 2.6
	 * Params:
	 *  iconName = an icon name
	 *  size = a stock icon size
	 * Returns:
	 *  a new GtkImage displaying the themed icon
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string iconName, GtkIconSize size)
	{
		// GtkWidget* gtk_image_new_from_icon_name (const gchar *icon_name,  GtkIconSize size);
		auto p = gtk_image_new_from_icon_name(Str.toStringz(iconName), size);
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_image_new_from_icon_name(Str.toStringz(iconName), size)");
		}
		this(cast(GtkImage*)p);
	}
	
code: end

outFile: Image

file: GtkLabel.html
struct: GtkLabel
class: Label
prefix: gtk_label_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: pango.PgAttributeList
structWrap: PangoAttrList* PgAttributeList
import: pango.PgLayout
structWrap: PangoLayout* PgLayout

out: gtk_label_get str
out: gtk_label_get_layout_offsets x
out: gtk_label_get_layout_offsets y
out: gtk_label_get_selection_bounds start
out: gtk_label_get_selection_bounds end

nocode: gtk_label_new
nocode: gtk_label_new_with_mnemonic
code: start
	/**
	 * Creates a new GtkLabel, containing the text in str.
	 * If characters in str are preceded by an underscore, they are
	 * underlined. If you need a literal underscore character in a label, use
	 * '__' (two underscores). The first underlined character represents a 
	 * keyboard accelerator called a mnemonic. The mnemonic key can be used 
	 * to activate another widget, chosen automatically, or explicitly using
	 * gtk_label_set_mnemonic_widget().
	 * If gtk_label_set_mnemonic_widget()
	 * is not called, then the first activatable ancestor of the GtkLabel
	 * will be chosen as the mnemonic widget. For instance, if the
	 * label is inside a button or menu item, the button or menu item will
	 * automatically become the mnemonic widget and be activated by
	 * the mnemonic.
	 * Params:
	 *  str = The text of the label, with an underscore in front of the
	 *  mnemonic character
	 *  mnemonic = when false uses the literal text passed in without mnemonic
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string str, bool mnemonic=true)
	{
		GtkLabel* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_label_new_with_mnemonic (const gchar *str);
			p = cast(GtkLabel*)gtk_label_new_with_mnemonic(Str.toStringz(str));
		}
		else
		{
			// GtkWidget* gtk_label_new (const gchar *str);
			p = cast(GtkLabel*)gtk_label_new(Str.toStringz(str));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_label_new");
		}

		this(p);
	}
code: end
outFile: Label

file: GtkProgressBar.html
struct: GtkProgressBar
class: ProgressBar
prefix: gtk_progress_bar_
prefix: gtk_
import: glib.Str
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: ProgressBar

file: GtkStatusbar.html
struct: GtkStatusbar
class: Statusbar
import: glib.Str
prefix: gtk_statusbar_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: Statusbar

file: GtkInfoBar.html
struct: GtkInfoBar
ctorStruct: GtkWidget
class: InfoBar
import: glib.Str
prefix:  gtk_info_bar_
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.HBox;
import: gtk.VButtonBox

nocode: gtk_info_bar_get_action_area
nocode: gtk_info_bar_get_content_area

code: start
	/** */
	public this(string[] buttonsText, ResponseType[] responses)
	{
		this();

		for ( int i=0 ; i<buttonsText.length && i<responses.length ; i++)
		{
			addButton(buttonsText[i], responses[i]);
		}
	}

	/** */
	public this(StockID[] stockIDs, ResponseType[] responses)
	{
		this();

		for ( int i=0 ; i<stockIDs.length && i<responses.length ; i++)
		{
			addButton(stockIDs[i], responses[i]);
		}
	}

	/** */
	public Widget addButton(StockID stockID, int responseId)
	{
		return addButton(StockDesc[stockID], responseId);
	}
	
	/** */
	public void addButtons(string[] buttonsText, ResponseType[] responses)
	{
		for ( int i=0 ; i<buttonsText.length && i<responses.length ; i++)
		{
			addButton(buttonsText[i], responses[i]);
		}
	}
	
	/** */
	public void addButtons(StockID[] stockIDs, ResponseType[] responses)
	{
		for ( int i=0 ; i<stockIDs.length && i<responses.length ; i++)
		{
			addButton(stockIDs[i], responses[i]);
		}
	}

	/**
	 * Returns the action area of info_bar.
	 * Since 2.18
	 * Returns: the action area.
	 */
	public VButtonBox getActionArea()
	{
		// GtkWidget * gtk_info_bar_get_action_area (GtkInfoBar *info_bar);
		auto p = gtk_info_bar_get_action_area(gtkInfoBar);
		if(p is null)
		{
			return null;
		}
		return new VButtonBox(cast(GtkVButtonBox*) p);
	}
	
	/**
	 * Returns the content area of info_bar.
	 * Since 2.18
	 * Returns: the content area.
	 */
	public HBox getContentArea()
	{
		// GtkWidget * gtk_info_bar_get_content_area (GtkInfoBar *info_bar);
		auto p = gtk_info_bar_get_content_area(gtkInfoBar);
		if(p is null)
		{
			return null;
		}
		return new HBox(cast(GtkHBox*) p);
	}
code: end
outFile: InfoBar

file: GtkStatusIcon.html
struct: GtkStatusIcon
class: StatusIcon
prefix: gtk_status_icon_
prefix: gtk_
import: glib.Str
import: gio.Icon
import: gio.IconIF
structWrap: GIcon* IconIF
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gdk.Screen
structWrap: GdkScreen* Screen
import: gtk.Menu
structWrap: GtkMenu* Menu
import: gtk.Tooltip
structWrap: GtkTooltip* Tooltip

out: gtk_status_icon_position_menu x
out: gtk_status_icon_position_menu y
out: gtk_status_icon_position_menu push_in
out: gtk_status_icon_get_geometry screen
out: gtk_status_icon_get_geometry area
out: gtk_status_icon_get_geometry orientation

nocode: gtk_status_icon_new_from_stock
nocode: gtk_status_icon_new_from_file
nocode: gtk_status_icon_new_from_icon_name
#new_from_icon_name conflicts with new_from_file.

code: start
	/**
	 * Creates a status icon displaying a stock icon. Sample stock icon
	 * names are StockID.OPEN, StockID.QUIT. You can register your
	 * own stock icon names, see gtk_icon_factory_add_default() and
	 * gtk_icon_factory_add().
	 * Since 2.10
	 * Params:
	 *  stock_id = a stock icon id
	 * Returns:
	 *  a new GtkStatusIcon
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (StockID stockID)
	{
		// GtkStatusIcon* gtk_status_icon_new_from_stock (const gchar *stock_id);
		auto p = gtk_status_icon_new_from_stock(Str.toStringz(StockDesc[stockID]));
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_status_icon_new_from_stock");
		}
		this(cast(GtkStatusIcon*)p);
	}

	/**
	 * Creates a status icon displaying an icon from the current icon theme.
	 * If the current icon theme is changed, the icon will be updated
	 * appropriately.
	 * Since 2.10
	 * Params:
	 *  iconName =  an icon name
	 *  loadFromFile = treat iconName as a filename and load that image
	 *  with gtk_status_icon_new_from_file.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string iconName, bool loadFromFile = false)
	{
		//TODO: look at a better way to do this.
		GtkStatusIcon* p;

		if(loadFromFile)
		{
			// GtkStatusIcon* gtk_status_icon_new_from_file (const gchar *filename);
			p = cast(GtkStatusIcon*)gtk_status_icon_new_from_file(Str.toStringz(iconName));
		}
		else
		{
			// GtkStatusIcon* gtk_status_icon_new_from_icon_name (const gchar *icon_name);
			p = cast(GtkStatusIcon*)gtk_status_icon_new_from_icon_name(Str.toStringz(iconName));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_status_icon_new_from_");
		}

		this(p);
	}
code: end
outFile: StatusIcon

file: GtkSpinner.html
struct: GtkSpinner
ctorStruct: GtkWidget
class: Spinner
prefix: gtk_spinner_
outFile: Spinner

###########################################################
### Buttons and Toggles ###################################
###########################################################

file: GtkButton.html
struct: GtkButton
class: Button
implements: ActivatableIF
prefix: gtk_button_
prefix: gtk_
import: glib.Str
import: gdk.Window
structWrap: GdkWindow* Window
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Image

# imports for Activatable Interface
import: gtk.ActivatableT
import: gtk.ActivatableIF

out: gtk_button_get_alignment xalign
out: gtk_button_get_alignment yalign

nocode: gtk_button_new_with_mnemonic
nocode: gtk_button_new_with_label
nocode: gtk_button_new_from_stock

code: start
	private static IconSize currentIconSize = IconSize.BUTTON;

	/** An arbitrary string to be used by the application */
	private string action;

	// add the Activatable capabilities
	mixin ActivatableT!(GtkButton);

	/** */
	public static void setIconSize(IconSize iconSize)
	{
		currentIconSize = iconSize;
	}

	/** */
	public static IconSize getIconSize()
	{
		return currentIconSize;
	}

	/** */
	public void setActionName(string action)
	{
		this.action = action;
	}

	/** */
	public string getActionName()
	{
		return action;
	}

	/**
	 * Creates a new GtkButton containing a label.
	 * If characters in label are preceded by an underscore, they are underlined.
	 * If you need a literal underscore character in a label, use '__' (two
	 * underscores). The first underlined character represents a keyboard
	 * accelerator called a mnemonic.
	 * Pressing Alt and that key activates the button.
	 * Params:
	 *  label = The text of the button, with an underscore in front of the
	 *  mnemonic character
	 *  mnemonic = true if the button has an mnemnonic
	 * Returns:
	 *  a new GtkButton
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string label, bool mnemonic=true)
	{
		GtkButton* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_button_new_with_mnemonic (const gchar *label);
			p = cast(GtkButton*)gtk_button_new_with_mnemonic(Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_button_new_with_label (const gchar *label);
			p = cast(GtkButton*)gtk_button_new_with_label(Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_button_new_with_label");
		}

		this(p);
	}
	
	/**
	 * Creates a new GtkButton containing the image and text from a stock item.
	 * Some stock ids have preprocessor macros like GTK_STOCK_OK and
	 * GTK_STOCK_APPLY.
	 * If stock_id is unknown, then it will be treated as a mnemonic
	 * label (as for gtk_button_new_with_mnemonic()).
	 * Params:
	 *  StockID = the name of the stock item
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (StockID stockID, bool hideLabel=false)
	{
		// GtkWidget* gtk_button_new_from_stock (const gchar *stock_id);
		if ( hideLabel )
		{
			this();
			Image image = new Image(stockID,currentIconSize);
			add(image);
		}
		else
		{
			auto p = gtk_button_new_from_stock(Str.toStringz(StockDesc[stockID]));

			if(p is null)
			{
				throw new ConstructionException("null returned by gtk_button_new_from_stock");
			}

			this(cast(GtkButton*) p);
		}
		
	}
	
	/** */
	public this(StockID stockID, void delegate(Button) dlg, bool hideLabel=false)
	{
		this(stockID, hideLabel);
		addOnClicked(dlg);
	}
	
	/** */
	public this(string label, void delegate(Button) dlg, bool mnemonic=true)
	{
		this(label, mnemonic);
		addOnClicked(dlg);
	}

	/** */
	public this(string label, void delegate(Button) dlg, string action)
	{
		this(label);
		setActionName(action);
		addOnClicked(dlg);
	}
	

code: end
outFile: Button

file: GtkCheckButton.html
struct: GtkCheckButton
class: CheckButton
import: glib.Str
import: gtk.Button
prefix: gtk_check_button_
prefix: gtk_

nocode: gtk_check_button_new_with_label
nocode: gtk_check_button_new_with_mnemonic

code: start
	/**
	 * Creates a new GtkCheckButton with a GtkLabel to the right of it.
	 * If mnemonic is true the label
	 * will be created using gtk_label_new_with_mnemonic(), so underscores
	 * in label indicate the mnemonic for the check button.
	 * Params:
	 *  label = The text of the button, with an underscore in front of the
	 *  mnemonic character
	 *  mnemonic = true if the button has an mnemnonic
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string label, bool mnemonic=true)
	{
		GtkCheckButton* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_check_button_new_with_mnemonic  (const gchar *label);
			p = cast(GtkCheckButton*)gtk_check_button_new_with_mnemonic(Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_check_button_new_with_label (const gchar *label);
			p = cast(GtkCheckButton*)gtk_check_button_new_with_label(Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_check_button_new_");
		}

		this(p);
	}

	/** */
	public this(string label, void delegate(CheckButton) onClicked, bool mnemonic=true)
	{
		this(label, mnemonic);
		addOnClicked(cast(void delegate(Button))onClicked);
	}
	
code: end

outFile: CheckButton

file: GtkRadioButton.html
struct: GtkRadioButton
class: RadioButton
prefix: gtk_radio_button_
prefix: gtk_
import: glib.Str
import: glib.ListSG
structWrap: GSList* ListSG
structWrap: GtkRadioButton* RadioButton

nocode: gtk_radio_button_new_with_label
nocode: gtk_radio_button_new_with_mnemonic
nocode: gtk_radio_button_new_with_label_from_widget
nocode: gtk_radio_button_new_with_mnemonic_from_widget

code: start
	/**
	 * Creates a new RadioButton with a text label.
	 * Params:
	 *  group = an existing radio button group.
	 *  label = the text label to display next to the radio button.
	 *  mnemonic = if true the label will be created using
	 *  gtk_label_new_with_mnemonic(), so underscores in label indicate the
	 *  mnemonic for the button.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (ListSG group, string label, bool mnemonic=true)
	{
		GtkRadioButton* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_radio_button_new_with_mnemonic  (GSList *group,  const gchar *label);
			p = cast(GtkRadioButton*)gtk_radio_button_new_with_mnemonic(
						group is null ? null : group.getListSGStruct(), 
						Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_radio_button_new_with_label (GSList *group,  const gchar *label);
			p = cast(GtkRadioButton*)gtk_radio_button_new_with_label(
						group is null ? null : group.getListSGStruct(), 
						Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_radio_button_new_");
		}

		this(p);
	}
	
	/**
	 * Creates a new RadioButton with a text label, adding it to the same group
	 * as group.
	 * Params:
	 *  radioButton = an existing RadioButton.
	 *  label = a text string to display next to the radio button.
	 *  mnemonic = if true the label
	 *  will be created using gtk_label_new_with_mnemonic(), so underscores
	 *  in label indicate the mnemonic for the button.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (RadioButton radioButton, string label, bool mnemonic=true)
	{
		GtkRadioButton* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_radio_button_new_with_mnemonic_from_widget  (GtkRadioButton *group,  const gchar *label);
			p = cast(GtkRadioButton*)gtk_radio_button_new_with_mnemonic_from_widget(
						radioButton.getRadioButtonStruct(),
						Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_radio_button_new_with_label_from_widget  (GtkRadioButton *group,  const gchar *label);
			p = cast(GtkRadioButton*)gtk_radio_button_new_with_label_from_widget(
						radioButton.getRadioButtonStruct(), 
						Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_radio_button_new_");
		}

		this(p);
	}

	/**
	 * Creates a new RadioButton with a text label,
	 * and creates a new group.
	 * Params:
	 *  label = a text string to display next to the radio button.
	 *  mnemonic = if true the label
	 *  will be created using gtk_label_new_with_mnemonic(), so underscores
	 *  in label indicate the mnemonic for the button.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string label, bool mnemonic=true)
	{
		this(cast(ListSG)null, label, mnemonic);
	}
code: end
outFile: RadioButton

file: GtkToggleButton.html
struct: GtkToggleButton
class: ToggleButton
prefix: gtk_toggle_button_
prefix: gtk_
import: glib.Str

nocode: gtk_toggle_button_new_with_label
nocode: gtk_toggle_button_new_with_mnemonic

code: start
	/**
	 * Creates a new toggle button with a text label.
	 * Params:
	 *  label = a string containing the message to be placed in the toggle button.
	 *  mnemonic =  if true the label
	 *  will be created using gtk_label_new_with_mnemonic(), so underscores
	 *  in label indicate the mnemonic for the button.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string label, bool mnemonic=true)
	{
		GtkToggleButton* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_toggle_button_new_with_mnemonic  (const gchar *label);
			p = cast(GtkToggleButton*)gtk_toggle_button_new_with_mnemonic(Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_toggle_button_new_with_label  (const gchar *label);
			p = cast(GtkToggleButton*)gtk_toggle_button_new_with_label(Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_toggle_button_new_");
		}

		this(p);
	}
code: end

outFile: ToggleButton

file: GtkLinkButton.html
struct: GtkLinkButton
class: LinkButton
prefix: gtk_link_button_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: LinkButton

file: GtkScaleButton.html
struct: GtkScaleButton
class: ScaleButton
implements: OrientableIF
prefix: gtk_scale_button_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT

nocode: gtk_scale_button_set_orientation
nocode: gtk_scale_button_get_orientation

array: gtk_scale_button_new icons
array: gtk_scale_button_set_icons icons

code: start
	// add the Orientable capabilities
	mixin OrientableT!(GtkScaleButton);
code: end
outFile: ScaleButton

file: GtkVolumeButton.html
struct: GtkVolumeButton
class: VolumeButton
prefix: gtk_volume_button_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: VolumeButton

###########################################################
### numeric/text Data Entry ###############################
###########################################################

file: GtkEntry.html
struct: GtkEntry
class: Entry
implements: EditableIF
implements: CellEditableIF
prefix: gtk_entry_
prefix: gtk_
import: glib.Str
import: gio.Icon
import: gio.IconIF
structWrap: GIcon* IconIF
import: gdk.Window
structWrap: GdkWindow* Window
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
import: gtk.Border
structWrap: GtkBorder* Border
import: gtk.EntryBuffer
structWrap: GtkEntryBuffer* EntryBuffer
import: gtk.EntryCompletion
structWrap: GtkEntryCompletion* EntryCompletion
import: pango.PgLayout
structWrap: PangoLayout* PgLayout
#Deprecated since 2.0 also shadowed setEditable in EditableIF
nocode: gtk_entry_select_region
nocode: gtk_entry_set_position
nocode: gtk_entry_set_editable

# imports for TreeModel Interface
import: gtk.EditableT
import: gtk.EditableIF

# imports for CellEditable Interface
import: gtk.CellEditableT
import: gtk.CellEditableIF

out: gtk_entry_get_layout_offsets x
out: gtk_entry_get_layout_offsets y

code: start
	// add the Editable capabilities
	mixin EditableT!(GtkEntry);

	// add the CellEditable capabilities
	mixin CellEditableT!(GtkEntry);

	/** */
	public this (string text)
	{
		this();
		setText(text);
	}

	/** */	
	public this (string text, int max)
	{
		this(max);
		setText(text);
	}

	/**
	 * Gets the stock id of action.
	 * Since 2.16
	 * Returns: the stock id
	 */
	public StockID getStockId(GtkEntryIconPosition iconPos)
	{
		// const gchar* gtk_entry_get_icon_stock (GtkEntry *entry, GtkEntryIconPosition icon_pos);
		string id = Str.toString(gtk_entry_get_icon_stock(gtkEntry, iconPos));

		foreach(i, desc; StockDesc)
		{
			if(desc == id)
				return cast(StockID)i;
		}

		return StockID.DISCARD;
	}

	/**
	 * Sets the stock id on action
	 * Since 2.16
	 * Params:
	 * stockId =  the stock id
	 */
	public void setStockId(GtkEntryIconPosition iconPos, StockID stockId)
	{
		// void gtk_entry_set_icon_from_stock (GtkEntry *entry, GtkEntryIconPosition icon_pos, const gchar *stock_id);
		gtk_entry_set_icon_from_stock(gtkEntry, iconPos, Str.toStringz(StockDesc[stockId]));
	}
code: end

outFile: Entry

file: GtkEntryBuffer.html
struct: GtkEntryBuffer
class: EntryBuffer
prefix: gtk_entry_buffer_
import: glib.Str
array: gtk_entry_buffer_new initial_chars n_initial_chars
array: gtk_entry_buffer_set_text chars n_chars
array: gtk_entry_buffer_insert_text chars n_chars
array: gtk_entry_buffer_emit_inserted_text chars n_chars
outFile: EntryBuffer

file: GtkEntryCompletion.html
struct: GtkEntryCompletion
class: EntryCompletion
implements: CellLayoutIF
prefix: gtk_entry_completion_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.TreeModel
import: gtk.TreeModelIF
structWrap: GtkTreeModel* TreeModelIF

#imports for CellLayout Interface.
import: gtk.CellLayoutIF
import: gtk.CellLayoutT

code: start
	// add the CellLayout capabilities
	mixin CellLayoutT!(GtkEntryCompletion);
code: end
outFile: EntryCompletion

file: GtkHScale.html
struct: GtkHScale
class: HScale
prefix: gtk_hscale_
prefix: gtk_
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: HScale

file: GtkVScale.html
struct: GtkVScale
class: VScale
prefix: gtk_vscale_
prefix: gtk_
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: VScale

file: GtkSpinButton.html
struct: GtkSpinButton
class: SpinButton
prefix: gtk_spin_button_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment

out: gtk_spin_button_get_increments step
out: gtk_spin_button_get_increments page
out: gtk_spin_button_get_range min
out: gtk_spin_button_get_range max

outFile: SpinButton

file: GtkEditable.html
struct: GtkEditable
class: EditableT
template: TStruct
prefix: gtk_editable_
prefix: gtk_
import: glib.Str

inout: gtk_editable_insert_text position
out: gtk_editable_get_selection_bounds start
out: gtk_editable_get_selection_bounds end

interface: EditableIF
outFile: EditableT

###########################################################
### Multiline Text Editor #################################
###########################################################

file: GtkTextIter.html
struct: GtkTextIter
class: TextIter
nostruct: GtkTextIter
prefix: gtk_text_iter_
prefix: gtk_
import: glib.Str
import: gtk.TextBuffer
structWrap: GtkTextBuffer* TextBuffer
structWrap: GtkTextIter* TextIter
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: glib.ListSG
structWrap: GSList* ListSG
import: gtk.TextChildAnchor
structWrap: GtkTextChildAnchor* TextChildAnchor
import: gtk.TextTag
structWrap: GtkTextTag* TextTag
import: gtk.TextAttributes
structWrap: GtkTextAttributes* TextAttributes
import: pango.PgLanguage
structWrap: PangoLanguage* PgLanguage

code: start
	/** */
	public this()
	{
		this(new GtkTextIter);
	}
	
code: end
outFile: TextIter

file: GtkTextMark.html
struct: GtkTextMark
class: TextMark
prefix: gtk_text_mark_
prefix: gtk_
import: glib.Str
import: gtk.TextBuffer
structWrap: GtkTextBuffer* TextBuffer
outFile: TextMark

file: GtkTextBuffer.html
struct: GtkTextBuffer
class: TextBuffer
prefix: gtk_text_buffer_
prefix: gtk_
import: glib.Str
import: glib.ErrorG
import: glib.GException
structWrap: GtkTextBuffer* TextBuffer
import: gtk.TextMark
structWrap: GtkTextMark* TextMark
import: gtk.TextIter
structWrap: GtkTextIter* TextIter
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
import: gtk.Widget
structWrap: GtkWidget* Widget
import: pango.PgTabArray
structWrap: PangoTabArray* PgTabArray
import: gtk.TextAttributes
structWrap: GtkTextAttributes* TextAttributes
import: gtk.TextTagTable
structWrap: GtkTextTagTable* TextTagTable
import: gtk.TextIter
structWrap: GtkTextIter* TextIter
import: gtk.TextTag
structWrap: GtkTextTag* TextTag
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.TextChildAnchor
structWrap: GtkTextChildAnchor* TextChildAnchor
import: gtk.TextMark
structWrap: GtkTextMark* TextMark
import: gtk.Clipboard
structWrap: GtkClipboard* Clipboard
import: gdk.Bitmap
structWrap: GdkBitmap* Bitmap
import: gtk.TargetList
structWrap: GtkTargetList* TargetList
import: std.stdarg

array: gtk_text_buffer_deserialize data length
array: gtk_text_buffer_get_deserialize_formats Return n_formats
array: gtk_text_buffer_get_serialize_formats Return n_formats
array: gtk_text_buffer_serialize Return length

nocode: gtk_text_buffer_set_text
nocode: gtk_text_buffer_insert_with_tags
nocode: gtk_text_buffer_insert_with_tags_by_name
nocode: gtk_text_buffer_create_tag

code: start

	/**
	 * Deletes current contents of buffer, and inserts text instead. If
	 * len is -1, text must be nul-terminated. text must be valid UTF-8.
	 * Params:
	 *  text = UTF-8 text to insert
	 */
	public void setText(string text)
	{
		// void gtk_text_buffer_set_text (GtkTextBuffer *buffer,  const gchar *text,  gint len);
		gtk_text_buffer_set_text(gtkTextBuffer, Str.toStringz(text), cast(int) text.length);
	}
	
	/**
	 * Inserts len bytes of text at position iter. If len is -1,
	 * text must be nul-terminated and will be inserted in its
	 * entirety. Emits the "insert_text" signal; insertion actually occurs
	 * in the default handler for the signal. iter is invalidated when
	 * insertion occurs (because the buffer contents change), but the
	 * default signal handler revalidates it to point to the end of the
	 * inserted text.
	 * Params:
	 *  iter = a position in the buffer
	 *  text = UTF-8 format text to insert
	 */
	public void insert(TextIter iter, string text)
	{
		// void gtk_text_buffer_insert (GtkTextBuffer *buffer,  GtkTextIter *iter,  const gchar *text,  gint len);
		gtk_text_buffer_insert(gtkTextBuffer, (iter is null) ? null : iter.getTextIterStruct(), Str.toStringz(text), cast(int) text.length);
	}
	
	/**
	 * Simply calls gtk_text_buffer_insert(), using the current
	 * cursor position as the insertion point.
	 * Params:
	 *  text = some text in UTF-8 format
	 */
	public void insertAtCursor(string text)
	{
		// void gtk_text_buffer_insert_at_cursor  (GtkTextBuffer *buffer,  const gchar *text,  gint len);
		gtk_text_buffer_insert_at_cursor(gtkTextBuffer, Str.toStringz(text), cast(int) text.length);
	}
	
	/**
	 * Like gtk_text_buffer_insert(), but the insertion will not occur if
	 * iter is at a non-editable location in the buffer. Usually you
	 * want to prevent insertions at ineditable locations if the insertion
	 * results from a user action (is interactive).
	 * default_editable indicates the editability of text that doesn't
	 * have a tag affecting editability applied to it. Typically the
	 * result of gtk_text_view_get_editable() is appropriate here.
	 * Params:
	 *  iter = a position in buffer
	 *  text = some UTF-8 text
	 *  defaultEditable = default editability of buffer
	 * Returns:
	 *  whether text was actually inserted
	 */
	public int insertInteractive(TextIter iter, string text, int defaultEditable)
	{
		// gboolean gtk_text_buffer_insert_interactive  (GtkTextBuffer *buffer,  GtkTextIter *iter,  const gchar *text,  gint len,  gboolean default_editable);
		return gtk_text_buffer_insert_interactive(gtkTextBuffer, (iter is null) ? null : iter.getTextIterStruct(), Str.toStringz(text), cast(int) text.length, defaultEditable);
	}
	
	/**
	 * Calls gtk_text_buffer_insert_interactive() at the cursor
	 * position.
	 * default_editable indicates the editability of text that doesn't
	 * have a tag affecting editability applied to it. Typically the
	 * result of gtk_text_view_get_editable() is appropriate here.
	 * Params:
	 *  text = text in UTF-8 format
	 *  defaultEditable = default editability of buffer
	 * Returns:
	 *  whether text was actually inserted
	 */
	public int insertInteractiveAtCursor(string text, int defaultEditable)
	{
		// gboolean gtk_text_buffer_insert_interactive_at_cursor  (GtkTextBuffer *buffer,  const gchar *text,  gint len,  gboolean default_editable);
		return gtk_text_buffer_insert_interactive_at_cursor(gtkTextBuffer, Str.toStringz(text), cast(int) text.length, defaultEditable);
	}

	/**
	 * Inserts text into buffer at iter, applying the list of tags to
	 * the newly-inserted text. The last tag specified must be NULL to
	 * terminate the list. Equivalent to calling gtk_text_buffer_insert(),
	 * then gtk_text_buffer_apply_tag() on the inserted text;
	 * gtk_text_buffer_insert_with_tags() is just a convenience function.
	 * Params:
	 *  iter = an iterator in buffer
	 *  text = UTF-8 text
	 *  ... = NULL-terminated list of tags to apply
	 */
	//version(Tango){} else -- still doesn't work on tango, but it compiles now
	public void insertWithTags(TextIter iter, string text, ... )
	{
		for (int i = 0; (i<_arguments.length) && (_arguments[i] == typeid(TextTag)); i++)
		{
			TextTag tag = va_arg!(TextTag)(_argptr);
			// void gtk_text_buffer_insert_with_tags  (GtkTextBuffer *buffer,  GtkTextIter *iter,  const gchar *text,  gint len,  GtkTextTag *first_tag,  ...);
			gtk_text_buffer_insert_with_tags(gtkTextBuffer, (iter is null) ? null : iter.getTextIterStruct(), Str.toStringz(text), cast(int) text.length, (tag is null) ? null : tag.getTextTagStruct(), null);
		}
	}
	
	/**
	 * Same as gtk_text_buffer_insert_with_tags(), but allows you
	 * to pass in tag names instead of tag objects.
	 * Params:
	 *  iter = position in buffer
	 *  text = UTF-8 text
	 *  ... = more tag names
	 */
 	// version(Tango){} else  -- still doesn't work on tango, but it compiles now 
 	public void insertWithTagsByName(TextIter iter, string text, ... )
	{
		for (int i = 0; (i<_arguments.length) && (_arguments[i] == typeid(string)); i++)
		{
			string tagName = va_arg!(string)(_argptr);
			// void gtk_text_buffer_insert_with_tags_by_name  (GtkTextBuffer *buffer,  GtkTextIter *iter,  const gchar *text,  gint len,  const gchar *first_tag_name,  ...);
			gtk_text_buffer_insert_with_tags_by_name(gtkTextBuffer, (iter is null) ? null : iter.getTextIterStruct(), Str.toStringz(text), cast(int) text.length, Str.toStringz(tagName), null);
		}
	}
	
	/**
	 * Create a new tag for this buffer
	 * Params:
	 *  tagName= can be null for no name
	 *  propertyName=
	 *  propertyValue=
	 */ 
	TextTag createTag(string tagName, string propertyName, int propertyValue, 
									   string propertyName1, string propertyValue1)
	{
		return new TextTag(
			gtk_text_buffer_create_tag(gtkTextBuffer,
				Str.toStringz(tagName), 
				Str.toStringz(propertyName),propertyValue,
				Str.toStringz(propertyName1),
				Str.toStringz(propertyValue1),
					null)
		);
			
	}
	/**
	 * Create a new tag for this buffer
	 * Params:
	 *  tagName= can be null for no name
	 *  propertyName=
	 *  propertyValue=
	 */
	TextTag createTag(string tagName, string propertyName, int propertyValue)
	{
		return new TextTag(
			gtk_text_buffer_create_tag(gtkTextBuffer, 
				Str.toStringz(tagName),
				Str.toStringz(propertyName),propertyValue,null)
		);
			
	}

	/**
	 * Create a new tag for this buffer
	 * Params:
	 *  tagName= can be null for no name
	 *  propertyName=
	 *  propertyValue=
	 */
	TextTag createTag(string tagName, string propertyName, double propertyValue)
	{
		return new TextTag(
			gtk_text_buffer_create_tag(gtkTextBuffer, Str.toStringz(tagName), Str.toStringz(propertyName),propertyValue,null)
		);
			
	}
	
	/**
	 * Create a new tag for this buffer
	 * Params:
	 *  tagName= can be null for no name
	 *  propertyName=
	 *  propertyValue=
	 *  propertyName2=
	 *  propertyValue2=
	 */
	TextTag createTag(string tagName, string propertyName, int propertyValue, string propertyName2, int propertyValue2)
	{
		return new TextTag(
			gtk_text_buffer_create_tag(gtkTextBuffer, Str.toStringz(tagName), Str.toStringz(propertyName), propertyValue, Str.toStringz(propertyName2), propertyValue2, null)
		);
	}

	/** Create a new tag for this buffer */
	TextTag createTag(string tagName, string propertyName, int propertyValue, string propertyName2, int propertyValue2, string propertyName3, int propertyValue3, string propertyName4, int propertyValue4, string propertyName5, int propertyValue5)
	{
		return new TextTag(
			gtk_text_buffer_create_tag(gtkTextBuffer, Str.toStringz(tagName), Str.toStringz(propertyName), propertyValue, Str.toStringz(propertyName2), propertyValue2, Str.toStringz(propertyName3), propertyValue3, Str.toStringz(propertyName4), propertyValue4, Str.toStringz(propertyName5), propertyValue5, null)
		);
	}

	/**
	 * Create a new tag for this buffer
	 * Params:
	 *  tagName= can be null for no name
	 *  propertyName=
	 *  propertyValue=
	 */
	TextTag createTag(string tagName, string propertyName, string propertyValue)
	{
		return new TextTag(
			gtk_text_buffer_create_tag(gtkTextBuffer, Str.toStringz(tagName), Str.toStringz(propertyName),Str.toStringz(propertyValue),null)
		);
			
	}

	/**
	 * Create a new tag for this buffer
	 * Params:
	 *  tagName = can be null for no name
	 *  propertyName=
	 *  propertyValue= 
	 */
	TextTag createTag(string tagName, string propertyName, Bitmap propertyValue)
	{
		return new TextTag(
			gtk_text_buffer_create_tag(gtkTextBuffer, Str.toStringz(tagName), Str.toStringz(propertyName),propertyValue.getBitmapStruct(),null)
		);
			
	}

	/**
	 * Obtain the entire text 
	 * Returns: The text string
	 */
	string getText()
	{
		TextIter start = new TextIter();
		TextIter end = new TextIter();
		getBounds(start,end);
		return Str.toString(gtk_text_buffer_get_slice(gtkTextBuffer, start.getTextIterStruct(), end.getTextIterStruct(), true));
	}

	/**
	 * Create a new tag for this buffer
	 * Params:
	 *  tagName= can be null for no name
	 *  propertyName=
	 *  propertyValue=
	 *  propertyName2=
	 *  propertyValue2=
	 */
	TextTag createTag(string tagName, 
			string propertyName, string propertyValue, 
			string propertyName2, int propertyValue2)
	{
		return new TextTag(
		gtk_text_buffer_create_tag(gtkTextBuffer, Str.toStringz(tagName), 
			Str.toStringz(propertyName), Str.toStringz(propertyValue), 
			Str.toStringz(propertyName2), propertyValue2, null)
		);
	}
code: end
outFile: TextBuffer

file: GtkTextTag.html
struct: GtkTextTag
class: TextTag
prefix: gtk_text_tag_
noprefix: gtk_text_attributes_
prefix: gtk_
import: glib.Str
import: gobject.ObjectG
structWrap: GObject* ObjectG
import: gdk.Event
structWrap: GdkEvent* Event
import: gtk.TextIter
structWrap: GtkTextIter* TextIter
outFile: TextTag

struct: GtkTextAttributes
class: TextAttributes
prefix: gtk_text_attributes_
strictPrefix: Y
import: gtk.TextAttributes
structWrap: GtkTextAttributes* TextAttributes
outFile: TextAttributes

file: GtkTextTagTable.html
struct: GtkTextTagTable
class: TextTagTable
prefix: gtk_text_tag_
prefix: gtk_
import: glib.Str
structWrap: GtkTextTagTable* TextTagTable
import: gtk.TextTag
structWrap: GtkTextTag* TextTag
outFile: TextTagTable

file: GtkTextView.html

struct: GtkTextView
class: TextView
prefix: gtk_text_view_
prefix: gtk_
noprefix: gtk_text_child_anchor_
import: glib.Str
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
import: gtk.TextBuffer
structWrap: GtkTextBuffer* TextBuffer
import: gtk.TextMark
structWrap: GtkTextMark* TextMark
import: gtk.TextIter
structWrap: GtkTextIter* TextIter
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
import: gtk.Widget
structWrap: GtkWidget* Widget
import: pango.PgTabArray
structWrap: PangoTabArray* PgTabArray
import: gtk.TextAttributes
structWrap: GtkTextAttributes* TextAttributes
import: gdk.Window
structWrap: GdkWindow* Window
import: gtk.TextChildAnchor
structWrap: GtkTextChildAnchor* TextChildAnchor
import: glib.ListG
structWrap: GList* ListG

out: gtk_text_view_get_line_at_y line_top
out: gtk_text_view_get_line_yrange y
out: gtk_text_view_get_line_yrange height
out: gtk_text_view_get_iter_at_position trailing
out: gtk_text_view_buffer_to_window_coords window_x
out: gtk_text_view_buffer_to_window_coords window_y
out: gtk_text_view_window_to_buffer_coords buffer_x
out: gtk_text_view_window_to_buffer_coords buffer_y

code: start

	/**
	 * Get the text line at the pixel y
	 */
	string getLineTextAt(gint y)
	{
		
		TextIter iter = new TextIter();
		int windowX;
		int windowY;
		bufferToWindowCoords(TextWindowType.TEXT, 0, y, windowX, windowY);

		gtk_text_view_get_line_at_y(gtkTextView, iter.getTextIterStruct(), y+y-windowY, null);
		
		TextIter iterEnd = new TextIter();
		TextBuffer buffer = getBuffer();
		buffer.getIterAtOffset(iterEnd, iter.getOffset()+iter.getCharsInLine());
		return buffer.getText(iter, iterEnd, false);
	}

	/**
	 * Simply appends some on the cursor position
	 * Params:
	 *  text = the text to append
	 */
	void insertText(string text)
	{
		TextBuffer buf = getBuffer();
		buf.insertAtCursor(text);
	}

	/**
	 * Simply appends some text to this view
	 * Params:
	 *  text = the text to append
	 */
	void appendText(string text, bool ensureVisible=true)
	body
	{
		TextBuffer buf = getBuffer();
		TextIter iter = new TextIter();
		buf.getEndIter(iter);
		buf.insert(iter, text);
		if ( ensureVisible )
		{
			gdouble within_margin = 0.0;
			bool use_align = false;
			gdouble xalign = 0.0;
			gdouble yalign = 0.0;
			scrollToMark(buf.createMark("",iter,true), within_margin, use_align, xalign, yalign);
		}
	}


code: end

outFile: TextView

struct: GtkTextChildAnchor
class: TextChildAnchor
import: glib.Str
prefix: gtk_text_child_anchor_
strictPrefix: Y
import: glib.ListG
structWrap: GList* ListG
outFile: TextChildAnchor

###########################################################
### Tree, List and Icon Grid Widgets ######################
###########################################################

file: GtkTreeModel.html

struct: GtkTreePath
class: TreePath
strictPrefix: Y
prefix: gtk_tree_path_
#prefix: gtk_
import: glib.Str
structWrap: GtkTreePath* TreePath

array: gtk_tree_path_get_indices Return getDepth()
array: gtk_tree_path_get_indices_with_depth Return depth

override: toString

nocode: gtk_tree_path_new
nocode: gtk_tree_path_new_first

nosignal: row-changed
nosignal: row-deleted
nosignal: row-has-child-toggled
nosignal: row-inserted
nosignal: rows-reordered

code: start
	/**
	 * Creates a new GtkTreePath. This structure refers to a row.
	 * Params:
	 * firstRow = if true this is the string representation of this path is "0"
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (bool firstRow=false)
	{
		GtkTreePath* p;

		if ( firstRow )
		{
			// GtkTreePath* gtk_tree_path_new_first (void);
			p = cast(GtkTreePath*)gtk_tree_path_new_first();
		}
		else
		{
			// GtkTreePath* gtk_tree_path_new (void);
			p = cast(GtkTreePath*)gtk_tree_path_new();
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_tree_path_new()");
		}

		this(p);
	}
code: end
outFile: TreePath

struct: GtkTreeModel
class: TreeModelT
template: TStruct
prefix: gtk_tree_model_
noprefix: gtk_tree_row_reference_
noprefix: gtk_tree_path_
noprefix: gtk_tree_iter_
import: glib.Str
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
import: gobject.Value
structWrap: GValue* Value
nocode: gtk_tree_model_get_value

array: gtk_tree_model_rows_reordered new_order
array: gtk_tree_path_get_indices_with_depth Return depth

interfaceCode: start
	/**
	 * Get the value of a column as a char array.
	 * this is the same calling getValue and get the string from the value object
	 */
	string getValueString(TreeIter iter, int column);

	/**
	 * Get the value of a column as a char array.
	 * this is the same calling getValue and get the int from the value object
	 */
	int getValueInt(TreeIter iter, int column);

	/**
	 * Sets iter to a valid iterator pointing to path.
	 * Params:
	 *  iter = The uninitialized GtkTreeIter.
	 *  path = The GtkTreePath.
	 * Returns:
	 *  TRUE, if iter was set.
	 */
	public int getIter(TreeIter iter, TreePath path);

	/**
	 * Initializes and sets value to that at column.
	 * When done with value, g_value_unset() needs to be called
	 * to free any allocated memory.
	 * Params:
	 * iter = The GtkTreeIter.
	 * column = The column to lookup the value at.
	 * value = (inout) (transfer none) An empty GValue to set.
	 */
	public Value getValue(TreeIter iter, int column, Value value = null);
interfaceCode: end

nocode: gtk_tree_model_get_iter

code: start
	/**
	 * Get the value of a column as a char array.
	 * this is the same calling getValue and get the string from the value object
	 */
	string getValueString(TreeIter iter, int column)
	{
		Value value = new Value();
		getValue(iter, column, value);
		return value.getString();
	}

	/**
	 * Get the value of a column as a char array.
	 * this is the same calling getValue and get the int from the value object
	 */
	int getValueInt(TreeIter iter, int column)
	{
		Value value = new Value();
		getValue(iter, column, value);
		return value.getInt();
	}

	/**
	 * Sets iter to a valid iterator pointing to path.
	 * Params:
	 *  iter = The uninitialized GtkTreeIter.
	 *  path = The GtkTreePath.
	 * Returns:
	 *  TRUE, if iter was set.
	 */
	public int getIter(TreeIter iter, TreePath path)
	{
		// gboolean gtk_tree_model_get_iter (GtkTreeModel *tree_model,  GtkTreeIter *iter,  GtkTreePath *path);
		iter.setModel(this);
		return gtk_tree_model_get_iter(
				getTreeModelTStruct(), 
				(iter is null) ? null : iter.getTreeIterStruct(), 
				(path is null) ? null : path.getTreePathStruct());
	}

	/**
	 * Initializes and sets value to that at column.
	 * When done with value, g_value_unset() needs to be called
	 * to free any allocated memory.
	 * Params:
	 * iter = The GtkTreeIter.
	 * column = The column to lookup the value at.
	 * value = (inout) (transfer none) An empty GValue to set.
	 */
	public Value getValue(TreeIter iter, int column, Value value = null)
	{
		if ( value is null )
			value = new Value();

		// void gtk_tree_model_get_value (GtkTreeModel *tree_model,  GtkTreeIter *iter,  gint column,  GValue *value);
		gtk_tree_model_get_value(getTreeModelTStruct(), (iter is null) ? null : iter.getTreeIterStruct(), column, (value is null) ? null : value.getValueStruct());

		return value;
	}
code: end

interface: TreeModelIF
outFile: TreeModelT


struct: GtkTreeIter
class: TreeIter
strictPrefix: Y
prefix: gtk_tree_iter_
#prefix: gtk_
import: glib.Str
structWrap: GtkTreeIter* TreeIter
import: gtk.TreeModelIF
import: gtk.TreePath
import: gtk.TreeIterError
import: gobject.Value

nosignal: row-changed
nosignal: row-deleted
nosignal: row-has-child-toggled
nosignal: row-inserted
nosignal: rows-reordered

code: start
	/**
	 * this will be set only when the iter
	 * is created from the model.
	 */
	GtkTreeModel* gtkTreeModel; 

	/** */
	public void setModel(GtkTreeModel* gtkTreeModel)
	{
		this.gtkTreeModel = gtkTreeModel;
	}

	/** */       
	public void setModel(TreeModelIF treeModel)
	{
		this.gtkTreeModel = treeModel.getTreeModelTStruct();
	}

	/**
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this(TreeModelIF treeModel, string treePath)
	{
		this(treeModel, new TreePath(treePath));
	}
	   
	/**
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this(TreeModelIF treeModel, TreePath treePath)
	{
		this();
		setModel(treeModel);
		if ( !gtk_tree_model_get_iter_from_string(
				treeModel.getTreeModelTStruct(),
				getTreeIterStruct(), Str.toStringz(treePath.toString())) )
		{
			throw new ConstructionException("null returned by gtk_tree_model_get_iter_from_string");
		}
	}
	
	/**
	* creates a new tree iteractor.
	* used TreeView.createIter and TreeView.append() to create iteractor for a tree or list
	*/
	this()
	{
		this(new GtkTreeIter);
	}

	/**
	 * Get Value
	 * Params:
	 *  column =
	 *  value =
	 */
	void getValue(int column, Value value)
	{
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getValue","Tree model not set");
		}
		gtk_tree_model_get_value(gtkTreeModel, gtkTreeIter, column, value.getValueStruct());
	}

	/**
	 * Get the value of a column as a string
	 * Params:
	 *  column = the column number
	 * Returns: a string representing the value of the column
	 */
	string getValueString(int column)
	{
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getValueString","Tree model not set");
		}
		Value value = new Value();
		gtk_tree_model_get_value(gtkTreeModel, gtkTreeIter, column, value.getValueStruct());
		//printf("TreeIter.getValuaString = %.*s\n", value.getString().toString());
		return value.getString();
	}

	/**
	 * Get the value of a column as an int
	 * Params:
	 *  column = the column number
	 * Returns: a string representing the value of the column
	 */
	int getValueInt(int column)
	{
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getValueInt", "Tree model not set");
		}
		Value value = new Value();
		gtk_tree_model_get_value(gtkTreeModel, gtkTreeIter, column, value.getValueStruct());
		return value.getInt();
	}

	/** */
	TreePath getTreePath()
	{
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getTreePath","Tree model not set");
		}
		return new TreePath(gtk_tree_model_get_path(gtkTreeModel, gtkTreeIter));
	}

	/**
	 * This return the path visible to the user.
	 */
	string getVisiblePath(string separator)
	{
		string vPath;
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getVisiblePath", "Tree model not set");
		}

		vPath = getValueString(0);
		TreeIter parent = getParent();
		while ( parent !is  null )
		{
			//printf("TreeIter.getVisiblePath parent = %.*s\n",parent.getValueString(0).toString());
			vPath = parent.getValueString(0) ~ separator ~ vPath;
			parent = parent.getParent();
		}
		
		//printf("TreeIter.getVisiblePath = %.*s\n", vPath.toString());
		
		return vPath;
	}
	
	/**
	 * Gets the parent of this iter
	 * Returns: the parent iter or null if can't get parent or an error occured
	 */
	TreeIter getParent()
	{
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getParent", "Tree model not set");
		}
		TreeIter parent = new TreeIter();
		bool gotParent = gtk_tree_model_iter_parent(gtkTreeModel, parent.getTreeIterStruct(), gtkTreeIter) == 0 ? false : true;
		if ( !gotParent )
		{
			return null;
		}
		parent.setModel(gtkTreeModel);
		return parent;
	}

	/** */
	TreeIter getGrandParent()
	{
		if ( gtkTreeModel  is  null )
		{
			throw new TreeIterError("getGrandParent", "Tree model not set");
		}
		TreeIter grandParent = this;
		TreeIter parent = grandParent.getParent();
		while ( parent !is null )
		{
			grandParent = parent;
			parent = grandParent.getParent();
		}
		
		return grandParent;
	}

	/** A unique stamp to catch invalid iterators */
	public int stamp()
	{
		return gtkTreeIter.stamp;
	}

	/** Ditto */
	public void stamp(int stamp)
	{
		gtkTreeIter.stamp = stamp;
	}

	/** Model specific data */
	public void* userData()
	{
		return gtkTreeIter.userData;
	}

	/** Ditto */
	public void userData(void* data)
	{
		gtkTreeIter.userData = data;
	}

	public struct IterData
	{
		/// Data fields.
		union
		{
			int     dataInt;
			long    dataLong;
			double  dataFloat;
			double  dataDouble;
			string  dataString;

			void*   dataUser;
		}

		TypeInfo type = typeid(void);
	}

	/**
	 * setUserData and getUserData provide simple boxing
	 * around the userData field in the TreeIter struct.
	 * Throws: TreeIterError for unsuported types or a type mismatch.
	 * Example:
	 * ---
	 * Treeiter iter = new TreeIter();
	 *
	 * iter.setUserData(20);
	 * int i = iter.getUserData!(int)();
	 * ---
	 */
	public void setUserData(T)(T data)
	{
		IterData* itData = new IterData;
		itData.type = typeid(T);

		static if(is(T == int))
		{
			itData.dataInt = data;
		}
		else static if(is(T == long))
		{
			itData.dataLong = data;
		}
		else static if(is(T == float))
		{
			itData.dataFloat = data;
		}
		else static if(is(T == double))
		{
			itData.dataDouble = data;
		}
		else static if(is(T == string))
		{
			itData.dataString = data;
		}
		else static if(is(T == void*))
		{
			itData.dataUser = data;
		}
		else
		{
			pragma(msg, "IterData Type not Suported");

			throw new TreeIterError("getUserData", "IterData Type not Suported");
		}

		gtkTreeIter.userData = itData;
	}

	/** Ditto */
	public T getUserData(T)()
	{
		IterData* itData = cast(IterData*)gtkTreeIter.userData;

		static if(is(T == int))
		{
			if(itData.type is typeid(T))
			{
				return itData.dataInt;
			}
			else
			{
				throw new TreeIterError("getUserData", "IterData is not: int");
			}
		}
		else static if(is(T == long))
		{
			if(itData.type is typeid(T))
			{
				return itData.dataLong;
			}
			else
			{
				throw new TreeIterError("getUserData", "IterData is not: long");
			}
		}
		else static if(is(T == float))
		{
			if(itData.type is typeid(T))
			{
				return itData.dataFloat;
			}
			else
			{
				throw new TreeIterError("getUserData", "IterData is not: float");
			}
		}
		else static if(is(T == double))
		{
			if(itData.type is typeid(T))
			{
				return itData.dataDouble;
			}
			else
			{
				throw new TreeIterError("getUserData", "IterData is not: double");
			}
		}
		else static if(is(T == string))
		{
			if(itData.type is typeid(T))
			{
				return itData.dataString;
			}
			else
			{
				throw new TreeIterError("getUserData", "IterData is not: string");
			}
		}
		else static if(is(T == void*))
		{
			if(itData.type is typeid(T))
			{
				return itData.dataUser;
			}
			else
			{
				throw new TreeIterError("getUserData", "IterData is not: void*");
			}
		}
		else
		{
			pragma(msg, "IterData Type not Suported");

			throw new TreeIterError("getUserData", "IterData Type not Suported");
		}
	}
code: end
outFile: TreeIter


struct: GtkTreeRowReference
class: TreeRowReference
strictPrefix: Y
prefix: gtk_tree_row_reference_
#prefix: gtk_
import: gtk.TreeModel
import: gtk.TreeModelIF
structWrap: GtkTreeModel* TreeModelIF
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
import: gobject.ObjectG
structWrap: GObject* ObjectG
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
structWrap: GtkTreeRowReference* TreeRowReference

array: gtk_tree_row_reference_reordered new_order

nosignal: row-changed
nosignal: row-deleted
nosignal: row-has-child-toggled
nosignal: row-inserted
nosignal: rows-reordered

outFile: TreeRowReference

file:
class: TreeIterError
extend: Exception
import(tango): tango.core.Exception

code: start
	/**
	 * A TreeIter error.
	 * thrown<br>
	 * - trying to access a method that requires a tree model and the tree model was never set
	 */
	public this(string method, string message)
	{
		super("TreeIter."~method~" : "~message);
	}

code: end
outFile: TreeIterError



file:
import: glib.Str
import: gobject.Type
import: gobject.ObjectG
import: gobject.Signals
import: gobject.Value
import: gtk.TreeIter
import: gtk.TreePath
import: gtk.TreeModelT
import: gtk.TreeModelIF
import: gtkc.gobject
import: gtkc.Loader
import: gtkc.paths

code: start
struct CustomTreeModelClass
{
	GObjectClass parentClass;
}

//We need this function for the interface implementation.
extern(C) GType function() c_gtk_tree_model_get_type;
alias c_gtk_tree_model_get_type gtk_tree_model_get_type;

/**
 */
public class TreeModel : ObjectG, TreeModelIF
{
	static GObjectClass* parentClass = null;
	
	mixin( _shared ~ "static this()
	{
		Linker.link(gtk_tree_model_get_type, \"gtk_tree_model_get_type\", LIBRARY.GTK);
	}");
	
	// Minimal implementation.
	mixin TreeModelT!(GtkTreeModel);
	
	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gtkTreeModel;
	}
	
	public this ()
	{
		auto p =  super(customTreeModelgetType(), null);
		gtkTreeModel = cast(GtkTreeModel*) p.getObjectGStruct();
		
		setDataFull("customTreeModel", cast(void*)this, cast(GDestroyNotify)&destroyNotify);
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GtkTreeModel* gtkTreeModel)
	{
		super(cast(GObject*)gtkTreeModel);
		this.gtkTreeModel = gtkTreeModel;
	}
	
	
	extern(C)
	{
		/*
		 *  here we register our new type and its interfaces
		 *  with the type system. If you want to implement
		 *  additional interfaces like GtkTreeSortable, you
		 *  will need to do it here.
		 */
		
		static GType customTreeModelgetType()
		{
			GType customTreeModelType = Type.fromName("CustomTreeModel");
			
			/* Some boilerplate type registration stuff */
			if (customTreeModelType == GType.INVALID)
			{
				GTypeInfo customTreeModelInfo =
				{
					CustomTreeModelClass.sizeof,                   /* class size */
					null,                                          /* base_init */
					null,                                          /* base_finalize */
					cast(GClassInitFunc) &customTreeModelClassInit,/* class init function */
					null,                                          /* class finalize */
					null,                                          /* class_data */
					GObject.sizeof,                                /* instance size */
					0,                                             /* n_preallocs */
					//cast(GInstanceInitFunc) &customTreeModelInit   /* instance init */
					null
				};
				GInterfaceInfo treeModelInfo =
				{
					cast(GInterfaceInitFunc) &customTreeModelInit,
					null,
					null
				};
				
				/* First register the new derived type with the GObject type system */
				customTreeModelType = Type.registerStatic (GType.OBJECT, "CustomTreeModel",
				&customTreeModelInfo, cast(GTypeFlags)0);
				
				/* Now register our GtkTreeModel interface with the type system */
				Type.addInterfaceStatic (customTreeModelType, gtk_tree_model_get_type() /*GTK_TYPE_TREE_MODEL*/, &treeModelInfo);
			}
			
			return customTreeModelType;
		}
		
		/*
		 *  boilerplate GObject/GType stuff.
		 *  Init callback for the type system,
		 *  called once when our new class is created.
		 */
		
		static void customTreeModelClassInit (void* klass)
		{
			GObjectClass* objectClass;
			
			parentClass = cast(GObjectClass*) Type.classPeekParent(klass);
			objectClass = cast(GObjectClass*) klass;
			
			objectClass.finalize = &customTreeModelFinalize;
		}
		
		/*
		 *  init callback for the interface registration
		 *  in customTreeModelGetType. Here we override
		 *  the GtkTreeModel interface functions that
		 *  we implement.
		 */
		
		static void customTreeModelInit (GtkTreeModelIface *iface)
		{
			iface.getFlags      = &customTreeModelGetFlags;
			iface.getNColumns   = &customTreeModelGetNColumns;
			iface.getColumnType = &customTreeModelGetColumnType;
			iface.getIter       = &customTreeModelGetIter;
			iface.getPath       = &customTreeModelGetPath;
			iface.getValue      = &customTreeModelGetValue;
			iface.iterNext      = &customTreeModelIterNext;
			iface.iterChildren  = &customTreeModelIterChildren;
			iface.iterHasChild  = &customTreeModelIterHasChild;
			iface.iterNChildren = &customTreeModelIterNChildren;
			iface.iterNthChild  = &customTreeModelIterNthChild;
			iface.iterParent    = &customTreeModelIterParent;
		}
		
		/*
		 *  this is called just before a custom list is
		 *  destroyed. Free dynamically allocated memory here.
		 */
		
		static void customTreeModelFinalize (GObject *object)
		{
			/* must chain up - finalize parent */
			parentClass.finalize(object);
		}
		
		static GtkTreeModelFlags customTreeModelGetFlags(GtkTreeModel *tree_model)
		{
			auto tm = ObjectG.getDObject!(TreeModel)(tree_model);
			
			return tm.getFlags();
		}
		
		static int customTreeModelGetNColumns(GtkTreeModel *tree_model)
		{
			auto tm = ObjectG.getDObject!(TreeModel)(tree_model);
			
			return tm.getNColumns();
		}
		
		static GType customTreeModelGetColumnType(GtkTreeModel *tree_model, int index)
		{
			auto tm = ObjectG.getDObject!(TreeModel)(tree_model);
			
			return tm.getColumnType(index);
		}
		
		static gboolean customTreeModelGetIter(GtkTreeModel *tree_model, GtkTreeIter *iter, GtkTreePath *path)
		{
			auto tm = ObjectG.getDObject!(TreeModel)(tree_model);
			
			return tm.getIter(ObjectG.getDObject!(TreeIter)(iter), ObjectG.getDObject!(TreePath)(path));
		}
		
		static GtkTreePath* customTreeModelGetPath(GtkTreeModel *tree_model, GtkTreeIter *iter)
		{
			auto tm = ObjectG.getDObject!(TreeModel)(tree_model);
			TreePath path = tm.getPath(ObjectG.getDObject!(TreeIter)(iter));
			
			return (path is null) ? null : path.getTreePathStruct();
		}
		
		static void customTreeModelGetValue(GtkTreeModel *tree_model, GtkTreeIter *iter, int column, GValue *value)
		{
			auto tm = ObjectG.getDObject!(TreeModel)(tree_model);
			
			tm.getValue(ObjectG.getDObject!(TreeIter)(iter), column, ObjectG.getDObject!(Value)(value));
		}
		
		static gboolean customTreeModelIterNext(GtkTreeModel *tree_model, GtkTreeIter *iter)
		{
			auto tm = ObjectG.getDObject!(TreeModel)(tree_model);
			
			return tm.iterNext(ObjectG.getDObject!(TreeIter)(iter));
		}
		
		static gboolean customTreeModelIterChildren(GtkTreeModel *tree_model, GtkTreeIter *iter, GtkTreeIter *parent)
		{
			auto tm = ObjectG.getDObject!(TreeModel)(tree_model);
			
			return tm.iterChildren(ObjectG.getDObject!(TreeIter)(iter), ObjectG.getDObject!(TreeIter)(parent));
		}
		
		static gboolean customTreeModelIterHasChild(GtkTreeModel *tree_model, GtkTreeIter *iter)
		{
			auto tm = ObjectG.getDObject!(TreeModel)(tree_model);
			
			return tm.iterHasChild(ObjectG.getDObject!(TreeIter)(iter));
		}
		
		static int customTreeModelIterNChildren(GtkTreeModel *tree_model, GtkTreeIter *iter)
		{
			auto tm = ObjectG.getDObject!(TreeModel)(tree_model);
			
			return tm.iterNChildren(ObjectG.getDObject!(TreeIter)(iter));
		}
		
		static gboolean customTreeModelIterNthChild(GtkTreeModel *tree_model, GtkTreeIter *iter, GtkTreeIter *parent, int n)
		{
			auto tm = ObjectG.getDObject!(TreeModel)(tree_model);
			
			return tm.iterNthChild(ObjectG.getDObject!(TreeIter)(iter), ObjectG.getDObject!(TreeIter)(parent), n);
		}
		
		static gboolean customTreeModelIterParent(GtkTreeModel *tree_model, GtkTreeIter *iter, GtkTreeIter *child)
		{
			auto tm = ObjectG.getDObject!(TreeModel)(tree_model);
			
			return tm.iterParent(ObjectG.getDObject!(TreeIter)(iter), ObjectG.getDObject!(TreeIter)(child));
		}
	}
}
code: end
outFile: TreeModel



file: GtkTreeSelection.html
struct: GtkTreeSelection
class: TreeSelection
prefix: gtk_tree_selection_
prefix: gtk_
import: gtk.TreeView
structWrap: GtkTreeView* TreeView
import: gtk.TreeModel
import: gtk.TreeModelIF
structWrap: GtkTreeModel* TreeModelIF
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
import: glib.ListG
structWrap: GList* ListG
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
import: gtk.TreeModelIF
import: gtk.TreeIter

out: gtk_tree_selection_get_selected model
nocode: gtk_tree_selection_get_selected_rows

code: start
	/**
	 * Returns an TreeIter set to the currently selected node if selection
	 * is set to GTK_SELECTION_SINGLE or GTK_SELECTION_BROWSE.
	 * This function will not work if you use selection is GTK_SELECTION_MULTIPLE.
	 * Returns: A TreeIter for the selected node.
	 */
	public TreeIter getSelected()
	{
		TreeModelIF model;
		TreeIter iter = new TreeIter();
		
		if ( getSelected(model, iter) )
		{
			iter.setModel(model);
			return iter;
		}
		else
		{
			return null;
		}
	}

	/**
	 * Creates a list of path of all selected rows. Additionally, if you are
	 * planning on modifying the model after calling this function, you may
	 * want to convert the returned list into a list of GtkTreeRowReferences.
	 * To do this, you can use gtk_tree_row_reference_new().
	 * To free the return value, use:
	 * g_list_foreach (list, gtk_tree_path_free, NULL);
	 * g_list_free (list);
	 * Since 2.2
	 * Params:
	 *  model = A pointer to set to the GtkTreeModel, or NULL.
	 * Returns:
	 *  A GList containing a GtkTreePath for each selected row.
	 */
	TreePath[] getSelectedRows(out TreeModelIF model)
	{
		TreePath[] paths;
		GtkTreeModel* outmodel = null;
		GList* gList = gtk_tree_selection_get_selected_rows(gtkTreeSelection, &outmodel);
		if ( gList !is null )
		{  
			ListG list = new ListG(gList);
			for ( int i=0 ; i<list.length() ; i++ )
			{
				paths ~= new TreePath(cast(GtkTreePath*)list.nthData(i));
			}
		}
		model = ObjectG.getDObject!(TreeModel, TreeModelIF)(outmodel);

		return paths;
	}

code: end


outFile: TreeSelection

file: GtkTreeViewColumn.html
struct: GtkTreeViewColumn
class: TreeViewColumn
implements: CellLayoutIF
prefix: gtk_tree_view_column_
prefix: gtk_
import: glib.Str
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
import: glib.ListG
structWrap: GList* ListG
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.TreeModelIF
structWrap: GtkTreeModel* TreeModelIF
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
import: glib.Str

#imports for CellLayout Interface.
import: gtk.CellLayoutIF
import: gtk.CellLayoutT

out: gtk_tree_view_column_cell_get_size x_offset
out: gtk_tree_view_column_cell_get_size y_offset
out: gtk_tree_view_column_cell_get_size width
out: gtk_tree_view_column_cell_get_size height
out: gtk_tree_view_column_cell_get_position start_pos
out: gtk_tree_view_column_cell_get_position width

#These are also implemented in CellLayoutT
nocode: gtk_tree_view_column_pack_start
nocode: gtk_tree_view_column_pack_end
nocode: gtk_tree_view_column_clear
nocode: gtk_tree_view_column_add_attribute
nocode: gtk_tree_view_column_clear_attributes

nocode: gtk_tree_view_column_new_with_attributes

code: start
	// add the CellLayout capabilities
	mixin CellLayoutT!(GtkTreeViewColumn);

	/**
	 * Creates a new Tree view column
	 * Params:
	 *  header = th column header text
	 *  renderer = the rederer for the column cells
	 *  type = the type of data to be displayed (shouldn't this be on the renderer?)
	 *  column = the column number
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	this(string header, CellRenderer renderer, string type, int column)
	{
		auto p = gtk_tree_view_column_new_with_attributes(
				Str.toStringz(header), 
				renderer.getCellRendererStruct(), 
				Str.toStringz(type),
				column,
				null);

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_tree_view_column_new_with_attributes");
		}

		this(p);
	}
code: end

outFile: TreeViewColumn

file: GtkTreeView.html
struct: GtkTreeView
class: TreeView
prefix: gtk_tree_view_
prefix: gtk_
import: glib.Str
import: gtk.TreeModel
import: gtk.TreeModelIF
structWrap: GtkTreeModel* TreeModelIF
import: gtk.TreeSelection
structWrap: GtkTreeSelection* TreeSelection
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
import: gtk.TreeViewColumn
structWrap: GtkTreeViewColumn* TreeViewColumn
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
import: glib.ListG
structWrap: GList* ListG
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
#import: gtk.TreePath*
#structWrap: GtkTreePath** TreePath*
#import: gtk.TreeViewColumn*
#structWrap: GtkTreeViewColumn** TreeViewColumn*
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
import: gdk.Window
structWrap: GdkWindow* Window
import: gtk.Tooltip
structWrap: GtkTooltip* Tooltip
#import: gtk.TargetEntry
#structWrap: GtkTargetEntry* TargetEntry
#import: gtk.TreeViewDropPosition
#structWrap: GtkTreeViewDropPosition* TreeViewDropPosition
import: gdk.Pixmap
structWrap: GdkPixmap* Pixmap
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
import: gtk.Entry
structWrap: GtkEntry* Entry

inout: gtk_tree_view_get_path_at_pos path
inout: gtk_tree_view_get_path_at_pos column
out: gtk_tree_view_get_path_at_pos cell_x
out: gtk_tree_view_get_path_at_pos cell_y
out: gtk_tree_view_get_cursor path
out: gtk_tree_view_get_cursor focus_column
out: gtk_tree_view_get_visible_range start_path
out: gtk_tree_view_get_visible_range end_path
out: gtk_tree_view_widget_to_tree_coords tx
out: gtk_tree_view_widget_to_tree_coords ty
out: gtk_tree_view_tree_to_widget_coords wx
out: gtk_tree_view_tree_to_widget_coords wy
out: gtk_tree_view_convert_bin_window_to_tree_coords tx
out: gtk_tree_view_convert_bin_window_to_tree_coords ty
out: gtk_tree_view_convert_bin_window_to_widget_coords wx
out: gtk_tree_view_convert_bin_window_to_widget_coords wy
out: gtk_tree_view_convert_tree_to_bin_window_coords bx
out: gtk_tree_view_convert_tree_to_bin_window_coords by
out: gtk_tree_view_convert_tree_to_widget_coords wx
out: gtk_tree_view_convert_tree_to_widget_coords wy
out: gtk_tree_view_convert_widget_to_bin_window_coords bx
out: gtk_tree_view_convert_widget_to_bin_window_coords by
out: gtk_tree_view_convert_widget_to_tree_coords tx
out: gtk_tree_view_convert_widget_to_tree_coords ty
array: gtk_tree_view_enable_model_drag_dest targets n_targets
array: gtk_tree_view_enable_model_drag_source targets n_targets
out: gtk_tree_view_get_drag_dest_row path
out: gtk_tree_view_get_drag_dest_row pos
out: gtk_tree_view_get_dest_row_at_pos path
out: gtk_tree_view_get_dest_row_at_pos pos
out: gtk_tree_view_get_tooltip_context model
out: gtk_tree_view_get_tooltip_context path

code: start
	/**
	 * Expands the row of the iter.
	 * Params:
	 *  iter =
	 *  openAll =
	 *  Returns =
	 */
	int expandRow(TreeIter iter, TreeModelIF model, int openAll)
	{
		return expandRow(model.getPath(iter), openAll);
	}

	/**
	 * gets the first selected iter or null if no rows are selected
	 */
	TreeIter getSelectedIter()
	{
		TreeIter iter = null;
		TreeSelection selection = getSelection();
		TreeModelIF model = getModel();
		TreePath[] paths = selection.getSelectedRows(model);
		if ( paths.length > 0 )
		{
			iter = new TreeIter();
			model.getIter(iter,paths[0]);
		}
		return iter;
	}

	/** */
	TreeIter[] getSelectedIters()
	{
		TreeIter[] iters;
		
		TreeIter iter = new TreeIter();
		TreeSelection selection = getSelection();
		TreeModelIF model = getModel();
		TreePath[] paths = selection.getSelectedRows(model);
		foreach ( TreePath p; selection.getSelectedRows(model) )
		{
			//iters.length = iters.length+1;
			//iters[iters.length-1] = model.getIter(iter,p);
			// iters ~= model.getIter(iter,p); >>> compile error can only concatenate arrays ???
			if ( model.getIter(iter,p) )
			{
				iters ~= iter;
				iter = new TreeIter();
			}
		}
		
		//printf("TreeView.getSelectedIters iters.lenght = %d\n", iters.length);
		return iters;
	}

	/**
	 * Inserts a column and sets it's attributes
	 * Params:
	 *  position =
	 *  title =
	 *  renderer =
	 *  editable =
	 * Returns: number of columns including the new one
	 */
	gint insertEditableColumn(int position, string title, CellRenderer renderer, bool editable)
	{
		// OK, this is a trick because of my ignorance on how to pass variable argument lists
		if ( position < 0 )
		{
			position = getColumns().length();
		}
		int tot = gtk_tree_view_insert_column_with_attributes(
			gtkTreeView, 
			position, 
			Str.toStringz(title),
			renderer.getCellRendererStruct(),
			Str.toStringz("text"),position,//v1.getV(),
			Str.toStringz("editable"),2,0);//v.getV(),0);
		return tot;
	}


	
code: end

outFile: TreeView

file: gtk-GtkTreeView-drag-and-drop.html
struct: GtkTreeDragSource
class: TreeDragSourceT
template: TStruct
prefix: gtk_tree_drag_source_
prefix: gtk_tree_
noprefix: gtk_tree_drag_dest_
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
#import: gtk.SelectionData
#structWrap: GtkSelectionData* SelectionData
import: gtk.TreeModelIF
import: gtk.TreeModel
structWrap: GtkTreeModel* TreeModelIF

out: gtk_tree_get_row_drag_data tree_model
out: gtk_tree_get_row_drag_data path

interface: TreeDragSourceIF
outFile: TreeDragSourceT

struct: GtkTreeDragDest
class: TreeDragDestT
template: TStruct
prefix: gtk_tree_drag_dest_
strictPrefix: Y
import: gtk.TreeModelIF
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
#import: gtk.SelectionData
#structWrap: GtkSelectionData* SelectionData

interfaceCode: start
	/**
	 * Sets selection data of target type GTK_TREE_MODEL_ROW. Normally used
	 * in a drag_data_get handler.
	 * Params:
	 * selectionData =  some GtkSelectionData
	 * treeModel =  a GtkTreeModel
	 * path =  a row in tree_model
	 * Returns: TRUE if the GtkSelectionData had the proper target type to allow us to set a tree row
	 */
	public static int setRowDragData(GtkSelectionData* selectionData, TreeModelIF treeModel, TreePath path);
	
	/**
	 * Obtains a tree_model and path from selection data of target type
	 * GTK_TREE_MODEL_ROW. Normally called from a drag_data_received handler.
	 * This function can only be used if selection_data originates from the same
	 * process that's calling this function, because a pointer to the tree model
	 * is being passed around. If you aren't in the same process, then you'll
	 * get memory corruption. In the GtkTreeDragDest drag_data_received handler,
	 * you can assume that selection data of type GTK_TREE_MODEL_ROW is
	 * in from the current process. The returned path must be freed with
	 * gtk_tree_path_free().
	 * Params:
	 * selectionData =  a GtkSelectionData
	 * treeModel =  a GtkTreeModel
	 * path =  row in tree_model
	 * Returns: TRUE if selection_data had target type GTK_TREE_MODEL_ROW and is otherwise valid
	 */
	public static int getRowDragData(GtkSelectionData* selectionData, GtkTreeModel** treeModel, GtkTreePath** path);
interfaceCode: end
interface: TreeDragDestIF
outFile: TreeDragDestT

file: GtkCellView.html
struct: GtkCellView
class: CellView
implements: CellLayoutIF
prefix: gtk_cell_view_
prefix: gtk_
import: glib.Str
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.TreeModel
import: gtk.TreeModelIF
structWrap: GtkTreeModel* TreeModelIF
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
#import: gtk.Requisition
#structWrap: GtkRequisition* Requisition
import: gdk.Color
structWrap: GdkColor* Color
import: glib.ListG
structWrap: GList* ListG

#imports for CellLayout Interface.
import: gtk.CellLayoutIF
import: gtk.CellLayoutT

out: gtk_cell_view_get_size_of_row requisition

nocode: gtk_cell_view_new_with_text
nocode: gtk_cell_view_new_with_markup

code: start
	// add the CellLayout capabilities
	mixin CellLayoutT!(GtkCellView);

	/**
	 * Creates a new GtkCellView widget, adds a GtkCellRendererText
	 * to it, and makes its show text.
	 * If markup is true the text can be marked up with the Pango text
	 * markup language.
	 * Since 2.6
	 * Params:
	 *  text = the text to display in the cell view
	 * Returns:
	 *  A newly created GtkCellView widget.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string text, bool markup=true)
	{
		GtkCellView* p;

		if ( markup )
		{
			// GtkWidget* gtk_cell_view_new_with_markup (const gchar *markup);
			p = cast(GtkCellView*)gtk_cell_view_new_with_markup(Str.toStringz(text));
		}
		else
		{
			// GtkWidget* gtk_cell_view_new_with_text (const gchar *text);
			p = cast(GtkCellView*)gtk_cell_view_new_with_text(Str.toStringz(text));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_cell_view_new_with_");
		}

		this(p);
	}
code: end

outFile: CellView

file: GtkIconView.html
struct: GtkIconView
class: IconView
implements: CellLayoutIF
prefix: gtk_icon_view_
prefix: gtk_
import: gtk.TreeModel
import: gtk.TreeModelIF
structWrap: GtkTreeModel* TreeModelIF
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
#import: gtk.TreePath*
#structWrap: GtkTreePath** TreePath*
#import: gtk.CellRenderer*
#structWrap: GtkCellRenderer** CellRenderer*
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
import: gtk.Tooltip
structWrap: GtkTooltip* Tooltip
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
import: glib.ListG
structWrap: GList* ListG
#import: gtk.TargetEntry
#structWrap: GtkTargetEntry* TargetEntry
#import: gtk.IconViewDropPosition
#structWrap: GtkIconViewDropPosition* IconViewDropPosition
import: gdk.Pixmap
structWrap: GdkPixmap* Pixmap

#imports for CellLayout Interface.
import: gtk.CellLayoutIF
import: gtk.CellLayoutT

out: gtk_icon_view_get_item_at_pos path
out: gtk_icon_view_get_item_at_pos cell
out: gtk_icon_view_convert_widget_to_bin_window_coords bx
out: gtk_icon_view_convert_widget_to_bin_window_coords by
out: gtk_icon_view_get_cursor path
out: gtk_icon_view_get_cursor cell
out: gtk_icon_view_get_visible_range start_path
out: gtk_icon_view_get_visible_range end_path
out: gtk_icon_view_get_tooltip_context model
out: gtk_icon_view_get_tooltip_context path
array: gtk_icon_view_enable_model_drag_source targets n_targets
array: gtk_icon_view_enable_model_drag_dest targets n_targets
out: gtk_icon_view_get_drag_dest_item path
out: gtk_icon_view_get_drag_dest_item pos
out: gtk_icon_view_get_dest_item_at_pos path
out: gtk_icon_view_get_dest_item_at_pos pos

code: start
	// add the CellLayout capabilities
	mixin CellLayoutT!(GtkIconView);
code: end
outFile: IconView

file: GtkTreeSortable.html
struct: GtkTreeSortable
class: TreeSortableT
template: TStruct
prefix: gtk_tree_sortable_
prefix: gtk_
#import: gtk.SortType
#structWrap: GtkSortType* SortType

out: gtk_tree_sortable_get_sort_column_id sort_column_id
out: gtk_tree_sortable_get_sort_column_id order

interface: TreeSortableIF
outFile: TreeSortableT

file: GtkTreeModelSort.html
struct: GtkTreeModelSort
class: TreeModelSort
implements: TreeModelIF
implements: TreeDragSourceIF
implements: TreeSortableIF
prefix: gtk_tree_model_sort_
prefix: gtk_
import: glib.Str
import: gtk.TreeModel
import: gtk.TreeModelIF
structWrap: GtkTreeModel* TreeModelIF
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter

# imports for TreeModel Interface
import: gtk.TreeModelT
#import: gtk.TreeModelIF

# imports for TreeDragSource Interface
import: gtk.TreeDragSourceT
import: gtk.TreeDragSourceIF

# imports for TreeSortable Interface
import: gtk.TreeSortableT
import: gtk.TreeSortableIF

code: start
	// add the TreeModel capabilities
	mixin TreeModelT!(GtkTreeModelSort);

	// add the TreeDragSource capabilities
	mixin TreeDragSourceT!(GtkTreeModelSort);

	// add the TreeSortable capabilities
	mixin TreeSortableT!(GtkTreeModelSort);
cade: end
outFile: TreeModelSort

file: GtkTreeModelFilter.html
struct: GtkTreeModelFilter
ctorStruct: GtkTreeModel
class: TreeModelFilter
implements: TreeModelIF
implements: TreeDragSourceIF
prefix: gtk_tree_model_filter_
prefix: gtk_
import: gtk.TreeModel
import: gtk.TreeModelIF
structWrap: GtkTreeModel* TreeModelIF
import: gtk.TreePath
structWrap: GtkTreePath* TreePath
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter

# imports for TreeModel Interface
import: gtk.TreeModelT
#import: gtk.TreeModelIF

# imports for TreeDragSource Interface
import: gtk.TreeDragSourceT
import: gtk.TreeDragSourceIF

array: gtk_tree_model_filter_set_modify_func types n_columns

code: start
	// add the TreeModel capabilities
	mixin TreeModelT!(GtkTreeModelFilter);

	// add the TreeDragSource capabilities
	mixin TreeDragSourceT!(GtkTreeModelFilter);
cade: end
outFile: TreeModelFilter

file: GtkCellLayout.html
struct: GtkCellLayout
class: CellLayoutT
template: TStruct
prefix: gtk_cell_layout_
prefix: gtk_
import: glib.Str
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
import: glib.ListG
structWrap: GList* ListG
interface: CellLayoutIF
outFile: CellLayoutT

file: GtkCellRenderer.html
struct: GtkCellRenderer
class: CellRenderer
prefix: gtk_cell_renderer_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
import: gdk.Window
structWrap: GdkWindow* Window
import: gdk.Event
structWrap: GdkEvent* Event
import: gtk.CellEditable
import: gtk.CellEditableIF
structWrap: GtkCellEditable* CellEditableIF

out: gtk_cell_renderer_get_size x_offset
out: gtk_cell_renderer_get_size y_offset
out: gtk_cell_renderer_get_size width
out: gtk_cell_renderer_get_size height
out: gtk_cell_renderer_get_fixed_size width
out: gtk_cell_renderer_get_fixed_size height
out: gtk_cell_renderer_get_alignment xalign
out: gtk_cell_renderer_get_alignment yalign
out: gtk_cell_renderer_get_padding xpad
out: gtk_cell_renderer_get_padding ypad

outFile: CellRenderer

file: GtkCellEditable.html
struct: GtkCellEditable
class: CellEditableT
template: TStruct
prefix: gtk_cell_editable_
prefix: gtk_
import: gdk.Event
structWrap: GdkEvent* Event
interface: CellEditableIF
outFile: CellEditableT

file:
class: CellEditable
extend: ObjectG
implements: CellEditableIF
import: gobject.ObjectG

# imports for CellEditable Interface
import: gtk.CellEditableT
import: gtk.CellEditableIF

code: start
	// Minimal implementation.
	mixin CellEditableT!(GtkCellEditable);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gtkCellEditable;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GtkCellEditable* gtkCellEditable)
	{
		super(cast(GObject*)gtkCellEditable);
		this.gtkCellEditable = gtkCellEditable;
	}
code: end
outFile: CellEditable

file: GtkCellRendererAccel.html
struct: GtkCellRendererAccel
ctorStruct: GtkCellRenderer
class: CellRendererAccel
prefix: gtk_cell_renderer_accel_
prefix: gtk_
import: glib.Str
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
outFile: CellRendererAccel

file: GtkCellRendererCombo.html
struct: GtkCellRendererCombo
ctorStruct: GtkCellRenderer
class: CellRendererCombo
prefix: gtk_cell_renderer_combo_
prefix: gtk_
import: glib.Str
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
outFile: CellRendererCombo

file: GtkCellRendererPixbuf.html
struct: GtkCellRendererPixbuf
ctorStruct: GtkCellRenderer
class: CellRendererPixbuf
prefix: gtk_cell_renderer_pixbuf_
prefix: gtk_
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
outFile: CellRendererPixbuf

file: GtkCellRendererProgress.html
struct:GtkCellRendererProgress
ctorStruct: GtkCellRenderer
class: CellRendererProgress
prefix: gtk_cell_renderer_progress_
prefix: gtk_
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
outFile: CellRendererProgress

file: GtkCellRendererSpin.html
struct: GtkCellRendererSpin
ctorStruct: GtkCellRenderer
class: CellRendererSpin
prefix: gtk_cell_renderer_spin_
prefix: gtk_
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
outFile: CellRendererSpin

file: GtkCellRendererText.html
struct: GtkCellRendererText
ctorStruct: GtkCellRenderer
class: CellRendererText
prefix: gtk_cell_renderer_text_
prefix: gtk_
import: glib.Str
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
outFile: CellRendererText

file: GtkCellRendererToggle.html
struct: GtkCellRendererToggle
ctorStruct: GtkCellRenderer
class: CellRendererToggle
prefix: gtk_cell_renderer_toggle_
prefix: gtk_
import: glib.Str
import: gtk.CellRenderer
structWrap: GtkCellRenderer* CellRenderer
outFile: CellRendererToggle

file: GtkCellRendererSpinner.html
struct: GtkCellRendererSpinner
ctorStruct: GtkCellRenderer
class: CellRendererSpinner
prefix: gtk_cell_renderer_spinner_
outFile: CellRendererSpinner

file:
code: start
	/**
	 * TreeNode interface
	 */
	public interface TreeNode
	{
		string getNodeValue(int column);
		int columnCount();
	}
code: end
outFile: TreeNode

file: GtkListStore.html
struct: GtkListStore
class: ListStore
implements: BuildableIF
implements: TreeModelIF
implements: TreeDragSourceIF
implements: TreeDragDestIF
implements: TreeSortableIF
prefix: gtk_list_store_
prefix: gtk_
import: gtk.TreeModel
import: glib.Str
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
import: gobject.Value
structWrap: GValue* Value

#imports for Buildable Interface.
import: gtk.BuildableIF
import: gtk.BuildableT

# imports for TreeModel Interface
import: gtk.TreeModelT
import: gtk.TreeModelIF

# imports for TreeDragSource Interface
import: gtk.TreeDragSourceT
import: gtk.TreeDragSourceIF

# imports for GtkTreeDragDest Interface
import: gtk.TreeDragDestT
import: gtk.TreeDragDestIF

# imports for TreeSortable Interface
import: gtk.TreeSortableT
import: gtk.TreeSortableIF

array: gtk_list_store_newv types n_columns
array: gtk_list_store_set_column_types types n_columns
array: gtk_list_store_set_valuesv values n_values
array: gtk_list_store_set_valuesv columns n_values
array: gtk_list_store_insert_with_valuesv values n_values
array: gtk_list_store_insert_with_valuesv columns n_values
array: gtk_list_store_reorder new_order

nocode: gtk_list_store_set

code: start
	// add the Buildable capabilities
	mixin BuildableT!(GtkListStore);

	// add the TreeModel capabilities
	mixin TreeModelT!(GtkListStore);

	// add the TreeDragSource capabilities
	mixin TreeDragSourceT!(GtkListStore);

	// add the TreeDragDest capabilities
	mixin TreeDragDestT!(GtkListStore);

	// add the TreeSortable capabilities
	mixin TreeSortableT!(GtkListStore);

	/**
	 * Creates a top level iteractor.
	 * I don't think lists have but the top level iteractor
	 */
	TreeIter createIter()
	{
		GtkTreeIter* iter = new GtkTreeIter;
		gtk_list_store_append(getListStoreStruct(), iter);
		return new TreeIter(iter);
	}
	
	/**
	 * sets the values for one row
	 * Params:
	 *  iter = the row iteractor
	 *  columns = an arrays with the columns to set
	 *  values = an arrays with the values
	 */
	void set(TreeIter iter, int [] columns, char*[] values)
	{
		for ( int i=0 ; i<columns.length && i<values.length; i++ )
		{
			//Value v = new Value(values[i]);
			//gtk_list_store_set(obj(), iter.getIter(), columns[i], v.getV(),-1);
			gtk_list_store_set(
					gtkListStore, 
					iter.getTreeIterStruct(), 
					columns[i], 
					values[i],-1);
		}
	}

	/** */
	void set(TreeIter iter, int [] columns, string[] values)
	{
		for ( int i=0 ; i<columns.length && i<values.length; i++ )
		{
			//Value v = new Value(values[i]);
			//gtk_list_store_set(obj(), iter.getIter(), columns[i], v.getV(),-1);
			gtk_list_store_set(
					gtkListStore, 
					iter.getTreeIterStruct(), 
					columns[i], 
					Str.toStringz(values[i]),-1);
		}
	}

	/** */
	void setValue(TreeIter iter, int column, string value)
	{
		Value v = new Value(value);
		gtk_list_store_set_value(gtkListStore, iter.getTreeIterStruct(), column, v.getValueStruct());
		//gtk_list_store_set_value(obj(), iter.getIter(), column, (GValue*)cChar(value));
	}

	/** */
	void setValue(TreeIter iter, int column, int value)
	{
		Value v = new Value(value);
		gtk_list_store_set_value(gtkListStore, iter.getTreeIterStruct(), column, v.getValueStruct());
	}

code: end
outFile: ListStore

file: GtkTreeStore.html
struct: GtkTreeStore
class: TreeStore
implements: TreeModelIF
implements: TreeDragSourceIF
implements: TreeDragDestIF
implements: TreeSortableIF
prefix: gtk_tree_store_
prefix: gtk_
import: glib.Str
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter
import: gobject.Value
structWrap: GValue* Value
import: gtk.TreeNode
import: gdk.Pixbuf;
import: gobject.Value;

# imports for TreeModel Interface
import: gtk.TreeModelT
import: gtk.TreeModelIF

# imports for TreeDragSource Interface
import: gtk.TreeDragSourceT
import: gtk.TreeDragSourceIF

# imports for GtkTreeDragDest Interface
import: gtk.TreeDragDestT
import: gtk.TreeDragDestIF

# imports for TreeSortable Interface
import: gtk.TreeSortableT
import: gtk.TreeSortableIF

array: gtk_tree_store_newv types n_columns
array: gtk_tree_store_set_column_types types n_columns
array: gtk_tree_store_set_valuesv columns n_values
array: gtk_tree_store_set_valuesv values n_values
array: gtk_tree_store_insert_with_valuesv columns n_values
array: gtk_tree_store_insert_with_valuesv values n_values
array: gtk_tree_store_reorder new_order

nocode: gtk_tree_store_set

code: start
	// add the TreeModel capabilities
	mixin TreeModelT!(GtkTreeStore);

	// add the TreeDragSource capabilities
	mixin TreeDragSourceT!(GtkTreeStore);

	// add the TreeDragDest capabilities
	mixin TreeDragDestT!(GtkTreeStore);

	// add the TreeSortable capabilities
	mixin TreeSortableT!(GtkTreeStore);

	/**
	 * Creates a top level iteractor.
	 * I don't think lists have but the top level iteractor
	 */
	TreeIter createIter(TreeIter parent=null)
	{
		GtkTreeIter* iter = new GtkTreeIter;
		gtk_tree_store_append(getTreeStoreStruct(), iter, (parent is null) ? null : parent.getTreeIterStruct());
		return new TreeIter(iter);
	}
	
	/**
	 * Sets one value into one cells.
	 * \todo confirm we need to destroy the Value instance
	 * Params:
	 *  iter = the tree iteractor, effectivly the row
	 *  column = to column number to set
	 *  value = the value
	 */
	void setValue(TreeIter iter, int column, string value)
	{
		gtk_tree_store_set(gtkTreeStore, iter.getTreeIterStruct(), column, Str.toStringz(value) , -1);
	}

	/** */
	void setValue(TreeIter iter, int column, int value)
	{
		gtk_tree_store_set(gtkTreeStore, iter.getTreeIterStruct(), column, value, -1);
	}


	
	/**
	 * \todo confirm we need to destroy the Value instance
	 */
	void setValue(TreeIter iter, int column, Pixbuf pixbuf)
	{
		Value v = new Value(pixbuf);
		gtk_tree_store_set_value(gtkTreeStore, iter.getTreeIterStruct(), column, v.getValueStruct());
	}


	/**
	 * sets the values for one row
	 * Params:
	 *  iter = the row iteractor
	 *  columns = an arrays with the columns to set
	 *  values = an arrays with the values
	 */
	void set(TreeIter iter, int [] columns, char*[] values)
	{
		for ( int i=0 ; i<columns.length && i<values.length; i++ )
		{
			//Value v = new Value(values[i]);
			//gtk_list_store_set(obj(), iter.getIter(), columns[i], v.getV(),-1);
			gtk_tree_store_set(
					gtkTreeStore, 
					iter.getTreeIterStruct(), 
					columns[i], 
					values[i],-1);
		}
	}

	/** */
	void set(TreeIter iter, int [] columns, string[] values)
	{
		for ( int i=0 ; i<columns.length && i<values.length; i++ )
		{
			//Value v = new Value(values[i]);
			//gtk_list_store_set(obj(), iter.getIter(), columns[i], v.getV(),-1);
			gtk_tree_store_set(
					gtkTreeStore, 
					iter.getTreeIterStruct(), 
					columns[i], 
					Str.toStringz(values[i]),-1);
		}
	}

	/**
	 * Sets an iteractor values from a tree node.
	 * This is the way to add a new row to the tree,
	 * the iteractor is either a top level iteractor created from createIter()
	 * or a nested iteractor created from append()
	 * Params:
	 *  iter = the iteractor to set
	 *  treeNode = the tree node
	 * See_Also: createIter(), append()
	 */
	void set(TreeIter iter, TreeNode treeNode)
	{
		int[] cols;
		string[] vals;
		for ( int i=0 ; i<treeNode.columnCount() ; i++ )
		{
			//printf(">>>>>>>>>>>>> requesting value for %d\n",i);
			cols ~= i;
			string value = treeNode.getNodeValue(i);
			if ( value  is  null )
			{
				vals ~= "";
			}
			else
			{
				vals ~= value;
			}
		}
		set(iter, cols, vals);				
	}


	/**
	 * Creates and prepends a new row to tree_store. If parent is non-NULL, then it will prepend
	 * the new row before the first child of parent, otherwise it will prepend a row
	 * to the top level. iter will be changed to point to this new row. The row
	 * will be empty after this function is called. To fill in values, you need to
	 * call gtk_tree_store_set() or gtk_tree_store_set_value().
	 * Params:
	 *  parent = A valid GtkTreeIter, or NULL
	 */
	public TreeIter prepend(TreeIter parent)
	{
		TreeIter iter = new TreeIter();
		// void gtk_tree_store_prepend (GtkTreeStore *tree_store,  GtkTreeIter *iter,  GtkTreeIter *parent);
		gtk_tree_store_prepend(gtkTreeStore, iter.getTreeIterStruct(), (parent is null) ? null : parent.getTreeIterStruct());
		return iter;
	}
	
	/**
	 * Creates and appends a new row to tree_store. If parent is non-NULL, then it will append the
	 * new row after the last child of parent, otherwise it will append a row to
	 * the top level. iter will be changed to point to this new row. The row will
	 * be empty after this function is called. To fill in values, you need to call
	 * gtk_tree_store_set() or gtk_tree_store_set_value().
	 * Params:
	 *  parent = A valid GtkTreeIter, or NULL
	 */
	public TreeIter append(TreeIter parent)
	{
		TreeIter iter = new TreeIter();
		// void gtk_tree_store_append (GtkTreeStore *tree_store,  GtkTreeIter *iter,  GtkTreeIter *parent);
		gtk_tree_store_append(gtkTreeStore, 
			iter.getTreeIterStruct(), 
			(parent is null) ? null : parent.getTreeIterStruct());
		return iter;
	}
code: end

outFile: TreeStore


###########################################################
### Menus, Combo Box, Toolbar #############################
###########################################################

file: GtkComboBox.html

struct: GtkComboBox
class: ComboBox
implements: CellLayoutIF
implements: CellEditableIF
import: atk.ObjectAtk
structWrap: AtkObject* ObjectAtk
prefix: gtk_combo_box_
prefix: gtk_
#noprefix: gtk_combo_box_new_text
#noprefix: gtk_combo_box_append_text
#noprefix: gtk_combo_box_insert_text
#noprefix: gtk_combo_box_prepend_text
#noprefix: gtk_combo_box_remove_text
import: glib.Str
import: gtk.TreeModel
import: gtk.TreeModelIF
structWrap: GtkTreeModel* TreeModelIF
import: gtk.TreeIter
structWrap: GtkTreeIter* TreeIter

#imports for CellLayout Interface.
import: gtk.CellLayoutIF
import: gtk.CellLayoutT

# imports for CellEditable Interface
import: gtk.CellEditableT
import: gtk.CellEditableIF

nocode: gtk_combo_box_new
nocode: gtk_combo_box_new_text
nocode: gtk_combo_box_new_with_entry

code: start

	private int count = 0;
	public int maxCount = 0;
	

	// add the CellLayout capabilities
	mixin CellLayoutT!(GtkComboBox);

	// add the CellEditable capabilities
	mixin CellEditableT!(GtkComboBox);

	/**
	 * Creates a new empty GtkComboBox.
	 * If text is true then
	 * constructs a new text combo box, which is a
	 * GtkComboBox just displaying strings. If you use this function to create
	 * a text combo box, you should only manipulate its data source with the
	 * following convenience functions: gtk_combo_box_append_text(),
	 * gtk_combo_box_insert_text(), gtk_combo_box_prepend_text() and
	 * gtk_combo_box_remove_text().
	 * Since 2.4
	 * Returns:
	 *  A new GtkComboBox.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (bool text=true)
	{
		GtkComboBox* p;
		if ( text )
		{
			// GtkWidget* gtk_combo_box_new_text (void);
			p = cast(GtkComboBox*)gtk_combo_box_new_text();
		}
		else
		{
			// GtkWidget* gtk_combo_box_new (void);
			p = cast(GtkComboBox*)gtk_combo_box_new();
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_combo_box_new");
		}

		this(p);
	}

	/** */
	public void setActiveText(string text, bool insert=false)
	{
            int active = 0;
            setActive(0);
            while ( getActive >= 0 ) // returns -1 if end of list if reached
            {
                if( text == getActiveText() ) return;
                ++active;
                setActive(active);
            }
            // was not found, the combo has now nothing selected
            if ( insert )
            {
                appendText(text);
                setActive(active);
            }
	}

	/** */
	int getIndex(string text)
	{
		TreeIter iter = new TreeIter();
		TreeModelIF model = getModel();
		iter.setModel(model);
		int index = 0;
		bool found = false;
		bool end = false;
		if ( model.getIterFirst(iter) )
		{
			while ( !end && iter !is  null && !found )
			{
				found = iter.getValueString(0) == text;
				if ( !found )
				{
					end = !model.iterNext(iter);
					++index;
				}
			}
		}
		else
		{
			end = true;
		}
		return end ? -1 : index;
	}

	/** */
	void prependOrReplaceText(string text)
	{
		int index = getIndex(text);
		if ( index > 0 )
		{
			removeText(index);
			prependText(text);
		}
		else if ( index == -1 )
		{
			prependText(text);
		}
	}


code: end
outFile: ComboBox

file: GtkComboBoxEntry.html

struct: GtkComboBoxEntry
class: ComboBoxEntry
prefix: gtk_combo_box_entry_
#noprefix: gtk_combo_box_entry_new_text
#noprefix: gtk_combo_box_append_text
#noprefix: gtk_combo_box_insert_text
#noprefix: gtk_combo_box_prepend_text
#noprefix: gtk_combo_box_remove_text
import: gtk.TreeModelIF
structWrap: GtkTreeModel* TreeModelIF
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment

nocode: gtk_combo_box_entry_new
nocode: gtk_combo_box_entry_new_text

code: start
	/**
	 * Creates a new GtkComboBoxEntry which has a GtkEntry as child. After
	 * construction, you should set a model using gtk_combo_box_set_model() and a
	 * text_column * using gtk_combo_box_entry_set_text_column().
	 * Since 2.4
	 * Returns:
	 *  A new GtkComboBoxEntry.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (bool text=true)
	{
		GtkComboBoxEntry* p;

		if ( text )
		{
			// GtkWidget* gtk_combo_box_entry_new_text (void);
			p = cast(GtkComboBoxEntry*)gtk_combo_box_entry_new_text();
		}
		else
		{
			// GtkWidget* gtk_combo_box_entry_new (void);
			p = cast(GtkComboBoxEntry*)gtk_combo_box_entry_new();
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_combo_box_entry_new");
		}

		this(p);
	}
code: end
outFile: ComboBoxEntry


file: GtkMenu.html
struct: GtkMenu
class: Menu
prefix: gtk_menu_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gdk.Screen
structWrap: GdkScreen* Screen
import: gtk.AccelGroup
structWrap: GtkAccelGroup* AccelGroup
import: glib.ListG
structWrap: GList* ListG
import: gtk.MenuItem

code: start
	/**
	 * Popups up this menu
	 * Params:
	 *  button = you can pass a button number here
	 *  activateTime = you can pass the time from an event here
	 */
	void popup(guint button, guint32 activateTime)
	{
		popup(null, null, null, null, button, activateTime);
	}
	
	/**
	 * Creates and append a submenu to this menu.
	 * This menu item that actualy has the sub menu is also created.
	 * Params:
	 *  label = the sub menu item label
	 * Returns: the new menu
	 */
	Menu appendSubmenu(string label)
	{
		MenuItem item = new MenuItem(label);
		append(item);
		Menu submenu = new Menu();
		item.setSubmenu(submenu);
		return submenu;
	}

	/** */
	void appendSubmenu(string label, Menu submenu)
	{
		MenuItem item = new MenuItem(label);
		append(item);
		item.setSubmenu(submenu);
	}

	/** */
	Menu prependSubmenu(string label)
	{
		MenuItem item = new MenuItem(label);
		prepend(item);
		Menu submenu = new Menu();
		item.setSubmenu(submenu);
		return submenu;
	}
code: end
outFile: Menu

file: GtkMenuBar.html
struct: GtkMenuBar
class: MenuBar
prefix: gtk_menu_bar_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Menu;
import: gtk.MenuItem;
structWrap: GtkMenu* Menu
structWrap: GtkMenuItem* MenuItem
code: start
	/** */
	Menu append(string label, bool rightJustify=false)
	{
		MenuItem item = new MenuItem(label);
		super.append(item);
		item.setRightJustified(rightJustify);
		Menu menu= new Menu();
		item.setSubmenu(menu);
		return menu;
	}

	/** */
	public override void append(Widget widget) 
	{ 
		super.append(widget); 
	}
code: end
outFile: MenuBar

file: GtkMenuItem.html
struct: GtkMenuItem
class: MenuItem
implements: ActivatableIF
prefix: gtk_menu_item_
prefix: gtk_
import: glib.Str
import: gtk.Widget
import: gtk.AccelGroup
structWrap: GtkWidget* Widget

# imports for Activatable Interface
import: gtk.ActivatableT
import: gtk.ActivatableIF

nocode: gtk_menu_item_new_with_label
nocode: gtk_menu_item_new_with_mnemonic

alias: activate itemActivate

override: select
override: deselect

code: start
	/** store the action code passed in by the applcation */
	private string actionLabel;

	// add the Activatable capabilities
	mixin ActivatableT!(GtkMenuItem);
	
	/** Gets the application set action code */
	public string getActionName()
	{
		if ( actionLabel is null )
		{
			actionLabel = "";
		}
		return actionLabel;
	}
	
	/**
	 * Creates a new menu item with a label and a listener and a action.
	 * used for backward compatibily with DUI.
	 */
	this(string label, void delegate(MenuItem)dlg, string action)
	{
		this(label);
		this.actionLabel = action;
		addOnActivate(dlg);
	}
	

	
	/**
	 * Creates a new Item associated with a "activate" delegate and with a action code
	 * and optionally accelGroup
	 */
	public this(void delegate(MenuItem) dlg, string label, string action, 
				bool mnemonic=true,
				AccelGroup accelGroup=null,
				char accelKey='\0',
				GdkModifierType modifierType=GdkModifierType.CONTROL_MASK,
				GtkAccelFlags accelFlags=GtkAccelFlags.VISIBLE
				)
	{
		this(label, mnemonic);
		this.actionLabel = action;
		addOnActivate(dlg);
		if ( accelGroup !is null && accelKey != '\0' )
		{
			addAccelerator("activate",accelGroup,accelKey,modifierType,accelFlags); 
		}
	}
	
	

	/**
	 * Creates a new Item associated with a "activate" delegate
	 */
	public this(void delegate(MenuItem) dlg, string label, bool mnemonic=true)
	{
		this(label, mnemonic);
		addOnActivate(dlg);
	}

	/**
	 * Creates a new GtkMenuItem whose child is a GtkLabel.
	 * Params:
	 *  label = the text for the label
	 *  mnemonic = if true the label
	 *  will be created using gtk_label_new_with_mnemonic(), so underscores
	 *  in label indicate the mnemonic for the menu item.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string label, bool mnemonic=true)
	{
		GtkMenuItem* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_menu_item_new_with_mnemonic (const gchar *label);
			p = cast(GtkMenuItem*)gtk_menu_item_new_with_mnemonic(Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_menu_item_new_with_label (const gchar *label);
			p = cast(GtkMenuItem*)gtk_menu_item_new_with_label(Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_menu_item_new_with_");
		}

		this(p);

		setName(label);
	}	
code: end
outFile: MenuItem

file: GtkImageMenuItem.html
struct: GtkImageMenuItem
class: ImageMenuItem
prefix: gtk_image_menu_item_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.AccelGroup
structWrap: GtkAccelGroup* AccelGroup

nocode: gtk_image_menu_item_new_with_label
nocode: gtk_image_menu_item_new_with_mnemonic
nocode: gtk_image_menu_item_new_from_stock

code: start
	/**
	 * Creates a new GtkImageMenuItem containing a label.
	 * If mnemonic it true the label
	 * will be created using gtk_label_new_with_mnemonic(), so underscores
	 * in label indicate the mnemonic for the menu item.
	 * Params:
	 *  label = the text of the menu item.
	 * Returns:
	 *  a new GtkImageMenuItem.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string label, bool mnemonic=true)
	{
		GtkImageMenuItem* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_image_menu_item_new_with_mnemonic  (const gchar *label);
			p = cast(GtkImageMenuItem*)gtk_image_menu_item_new_with_mnemonic(Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_image_menu_item_new_with_label  (const gchar *label);
			p = cast(GtkImageMenuItem*)gtk_image_menu_item_new_with_label(Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_image_menu_item_new_with_");
		}

		this(p);
	}

	/**
	 * Creates a new GtkImageMenuItem containing the image and text from a
	 * stock item. Some stock ids have preprocessor macros like GTK_STOCK_OK
	 * and GTK_STOCK_APPLY.
	 * If you want this menu item to have changeable accelerators, then pass in
	 * NULL for accel_group. Next call gtk_menu_item_set_accel_path() with an
	 * appropriate path for the menu item, use gtk_stock_lookup() to look up the
	 * standard accelerator for the stock item, and if one is found, call
	 * gtk_accel_map_add_entry() to register it.
	 * Params:
	 * StockID = the name of the stock item
	 * accelGroup =  the GtkAccelGroup to add the menu items accelerator to,
	 *  or NULL.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (StockID stockID, AccelGroup accelGroup)
	{
		// GtkWidget* gtk_image_menu_item_new_from_stock (const gchar *stock_id,  GtkAccelGroup *accel_group);
		auto p = gtk_image_menu_item_new_from_stock(Str.toStringz(StockDesc[stockID]), (accelGroup is null) ? null : accelGroup.getAccelGroupStruct());
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_image_menu_item_new_from_stock");
		}
		this(cast(GtkImageMenuItem*) p);
	}
code: end

outFile: ImageMenuItem

file: GtkRadioMenuItem.html
struct: GtkRadioMenuItem
class: RadioMenuItem
prefix: gtk_radio_menu_item_
prefix: gtk_
import: glib.Str
import: glib.ListSG
structWrap: GSList* ListSG
structWrap: GtkRadioMenuItem* RadioMenuItem

nocode: gtk_radio_menu_item_new_with_label
nocode: gtk_radio_menu_item_new_with_mnemonic
nocode: gtk_radio_menu_item_new_with_mnemonic_from_widget
nocode: gtk_radio_menu_item_new_with_label_from_widget

code: start
	/**
	 * Creates a new GtkRadioMenuItem whose child is a simple GtkLabel.
	 * The new GtkRadioMenuItem is added to the same group as group.
	 * If mnemonic is true the label will be
	 * created using gtk_label_new_with_mnemonic(), so underscores in label
	 * indicate the mnemonic for the menu item.
	 * Since 2.4
	 * Params:
	 *  group = an existing GtkRadioMenuItem
	 *  label = the text for the label
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (RadioMenuItem radioMenuItem, string label, bool mnemonic=true)
	{
		GtkRadioMenuItem* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_radio_menu_item_new_with_mnemonic_from_widget  (GtkRadioMenuItem *group,  const gchar *label);
			p = cast(GtkRadioMenuItem*)gtk_radio_menu_item_new_with_mnemonic_from_widget(
				radioMenuItem.getRadioMenuItemStruct(), Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_radio_menu_item_new_with_label_from_widget  (GtkRadioMenuItem *group,  const gchar *label);
			p = cast(GtkRadioMenuItem*)gtk_radio_menu_item_new_with_label_from_widget(
				radioMenuItem.getRadioMenuItemStruct(), Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_radio_menu_item_new_with_");
		}

		this(p);
	}
	
	/**
	 * Creates a new GtkRadioMenuItem whose child is a simple GtkLabel.
	 * Params:
	 *  group = the group to which the radio menu item is to be attached
	 *  label = the text for the label
	 *  mnemonic = if true the label
	 *  will be created using gtk_label_new_with_mnemonic(), so underscores
	 *  in label indicate the mnemonic for the menu item.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (ListSG group, string label, bool mnemonic=true)
	{
		GtkRadioMenuItem* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_radio_menu_item_new_with_mnemonic  (GSList *group,  const gchar *label);
			p = cast(GtkRadioMenuItem*)gtk_radio_menu_item_new_with_mnemonic(
				group is null ? null : group.getListSGStruct(), Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_radio_menu_item_new_with_label  (GSList *group,  const gchar *label);
			p = cast(GtkRadioMenuItem*)gtk_radio_menu_item_new_with_label(
				group is null ? null : group.getListSGStruct(), Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_radio_menu_item_new_with_");
		}

		this(p);
	}
code: end
outFile: RadioMenuItem

file: gtk-gtkcheckmenuitem.html
struct: GtkCheckMenuItem
class: CheckMenuItem
prefix: gtk_check_menu_item_
prefix: gtk_
import: glib.Str

nocode: gtk_check_menu_item_new_with_label
nocode: gtk_check_menu_item_new_with_mnemonic

code: start
	/**
	 * Creates a new GtkCheckMenuItem with a label.
	 * Params:
	 *  label = the string to use for the label.
	 *  mnemonic = if true the label
	 *  will be created using gtk_label_new_with_mnemonic(), so underscores
	 *  in label indicate the mnemonic for the menu item.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string label, bool mnemonic=true)
	{
		GtkCheckMenuItem* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_check_menu_item_new_with_mnemonic  (const gchar *label);
			p = cast(GtkCheckMenuItem*)gtk_check_menu_item_new_with_mnemonic(Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_check_menu_item_new_with_label  (const gchar *label);
			p = cast(GtkCheckMenuItem*)gtk_check_menu_item_new_with_label(Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_check_menu_item_new_with_");
		}

		this(p);
	}
code: end

outFile: CheckMenuItem

file: GtkSeparatorMenuItem.html
struct: GtkSeparatorMenuItem
class: SeparatorMenuItem
prefix: gtk_separator_menu_item_
prefix: gtk_
outFile: SeparatorMenuItem

file: GtkTearoffMenuItem.html
struct: GtkTearoffMenuItem
class: TearoffMenuItem
prefix: gtk_tearoff_menu_item_
prefix: gtk_
outFile: TearoffMenuItem

file: GtkToolShell.html
struct: GtkToolShell
class: ToolShellT
template: TStruct
prefix: gtk_tool_shell_
import: gtk.SizeGroup
structWrap: GtkSizeGroup* SizeGroup
alias: getStyle toolShellGetStyle
nocode: gtk_tool_shell_get_orientation
interfaceCode: start
	/**
	 * Retrieves the current orientation for the tool shell. Tool items must not
	 * call this function directly, but rely on gtk_tool_item_get_orientation()
	 * instead.
	 * Since 2.14
	 * Returns: the current orientation of shell
	 */
	public GtkOrientation getOrientation();
interfaceCode: end
interface: ToolShellIF
outFile: ToolShellT

file: GtkToolbar.html
struct: GtkToolbar
class: Toolbar
implements: OrientableIF
implements: ToolShellIF
prefix: gtk_toolbar_
prefix: gtk_
import: glib.Str
import: gtk.Widget
import: gtk.Button
import: gtk.ToolItem
structWrap: GtkToolItem* ToolItem
structWrap: GtkWidget* Widget

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT
nocode: gtk_toolbar_set_orientation
nocode: gtk_toolbar_get_orientation

#imports for ToolShell Interface.
import: gtk.ToolShellIF
import: gtk.ToolShellT
nocode: gtk_toolbar_get_icon_size
nocode: gtk_toolbar_get_relief_style

alias: getStyle toolbarGetStyle

nocode: gtk_toolbar_insert

code: start
	// add the Orientable capabilities
	mixin OrientableT!(GtkToolbar);

	// add the ToolShell capabilities
	mixin ToolShellT!(GtkToolbar);

	/**
	 * Insert a GtkToolItem into the toolbar at position pos.
	 * If pos is 0 the item is prepended to the start of the toolbar. If pos is negative, the item is appended to the end of the toolbar.
	 * Since 2.4 
	 * Params:
	 * toolItem  = a GtkToolItem
	 * pos = the position of the new item
	 */
	public void insert (ToolItem toolItem, int pos=-1)
	{
		gtk_toolbar_insert(gtkToolbar, toolItem.getToolItemStruct(), pos);
	}

	/** */	
	public Widget insertStock(StockID stockId, string tooltipText, string tooltipPrivateText, GCallback callback, void* userData, int position)
	{
		return insertStock(getId(stockId), tooltipText, tooltipPrivateText, callback, userData, position);
	}

	/** */
	public Widget insertStock(string stockId, string tooltipText, string tooltipPrivateText, int position)
	{
		return insertStock(stockId, tooltipText, tooltipPrivateText, null, null, position);
	}
	
	/** */
	public Widget insertStock(StockID stockId, string tooltipText, string tooltipPrivateText, int position)
	{
		return insertStock(getId(stockId), tooltipText, tooltipPrivateText, null, null, position);
	}

	/** */
	Button insertButton(StockID stockID,
			string tooltipText, string tooltipPrivateText,
			gint position)
	{
		Button button = new Button(
				cast(GtkButton*)gtk_toolbar_insert_stock(
					gtkToolbar,
					Str.toStringz(StockDesc[stockID]),
					Str.toStringz(tooltipText), 
					Str.toStringz(tooltipPrivateText), 
					null, null, 
					position)
			);
		return button;
	}

code: end
outFile: Toolbar

file: GtkToolItem.html
struct: GtkToolItem
class: ToolItem
implements: ActivatableIF
prefix: gtk_tool_item_
prefix: gtk_
import: glib.Str
import: gtk.SizeGroup
structWrap: GtkSizeGroup* SizeGroup
import: gtk.Tooltips
structWrap: GtkTooltips* Tooltips
import: gtk.Widget
structWrap: GtkWidget* Widget

# imports for Activatable Interface
import: gtk.ActivatableT
import: gtk.ActivatableIF

override: setTooltipText
override: setTooltipMarkup

code: start
	// add the Activatable capabilities
	mixin ActivatableT!(GtkToolItem);

	/**
	 * Sets this widget tooltip
	 * Deprecated: Since 2.12 use setTooltipText() or setTooltipMarkup()
	 * Params:
	 *  tipText = the tooltip
	 *  tipPrivate = a private text
	 */
	override void setTooltip(string tipText, string tipPrivate)
	{
		Tooltips tt = new Tooltips();
		tt.setTip(this, tipText, tipPrivate);
	}

code: end

outFile: ToolItem

file: GtkToolPalette.html
struct: GtkToolPalette
ctorStruct: GtkWidget
class: ToolPalette
implements: OrientableIF
prefix: gtk_tool_palette_
alias: getStyle getToolbarStyle
import: glib.Str
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
#import: gtk.TargetEntry
#structWrap: GtkTargetEntry* TargetEntry
import: gtk.ToolItem
structWrap: GtkToolItem* ToolItem
import: gtk.ToolItemGroup
structWrap: GtkToolItemGroup* ToolItemGroup
import: gtk.Widget
structWrap: GtkWidget* Widget

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT

code: start
	// add the Orientable capabilities
	mixin OrientableT!(GtkToolPalette);
code: end
outFile: ToolPalette

file: GtkToolItemGroup.html
struct: GtkToolItemGroup
ctorStruct: GtkWidget
class: ToolItemGroup
implements: ToolShellIF
prefix: gtk_tool_item_group_
alias: getStyle getToolbarStyle
import: glib.Str
import: gtk.ToolItem
structWrap: GtkToolItem* ToolItem
import: gtk.Widget
structWrap: GtkWidget* Widget

#imports for ToolShell Interface.
import: gtk.ToolShellIF
import: gtk.ToolShellT

code: start
	// add the ToolShell capabilities
	mixin ToolShellT!(GtkToolItemGroup);

	/**
	 * Retrieves the current orientation for the tool shell. Tool items must not
	 * call this function directly, but rely on gtk_tool_item_get_orientation()
	 * instead.
	 * Since 2.14
	 * Returns: the current orientation of shell
	 */
	public GtkOrientation getOrientation()
	{
		// GtkOrientation gtk_tool_shell_get_orientation (GtkToolShell *shell);
		return gtk_tool_shell_get_orientation(getToolShellTStruct());
	}
code: end
outFile: ToolItemGroup

file: GtkSeparatorToolItem.html
struct: GtkSeparatorToolItem
ctorStruct: GtkToolItem
class: SeparatorToolItem
prefix: gtk_separator_tool_item_
prefix: gtk_
import: gtk.ToolItem
structWrap: GtkToolItem* ToolItem
outFile: SeparatorToolItem

file: GtkToolButton.html
struct: GtkToolButton
ctorStruct: GtkToolItem
class: ToolButton
prefix: gtk_tool_button_
prefix: gtk_
import: glib.Str
import: gtk.ToolItem
#structWrap: GtkToolItem* ToolItem
import: gtk.Widget
structWrap: GtkWidget* Widget

code: start
	/** An arbitrary string to be used by the application */
	private string action;

	/** */
	public void setActionName(string action)
	{
		this.action = action;
	}
	
	/** */
	public string getActionName()
	{
		return action;
	}

	/** */
	public this (StockID stockID)
	{
		this(StockDesc[stockID]);
	}
code: end

outFile: ToolButton

file: GtkMenuToolButton.html
struct: GtkMenuToolButton
ctorStruct: GtkToolItem
class: MenuToolButton
prefix: gtk_menu_tool_button_
prefix: gtk_
import: glib.Str
import: gtk.ToolItem
structWrap: GtkToolItem* ToolItem
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Tooltips
structWrap: GtkTooltips* Tooltips
import: gtk.Menu


nocode: gtk_menu_tool_button_new
nocode: gtk_menu_tool_button_new_from_stock
nocode: gtk_menu_tool_button_get_menu

code: start
	/**
	 * Creates a new GtkMenuToolButton using icon_widget as icon and
	 * label as label.
	 * Since 2.6
	 * Params:
	 *  iconWidget = a widget that will be used as icon widget, or NULL
	 *  label = a string that will be used as label, or NULL
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this(Widget iconWidget, string label)
	{
		// GtkToolItem* gtk_menu_tool_button_new (GtkWidget *icon_widget,  const gchar *label);
		auto p = gtk_menu_tool_button_new((iconWidget is null) ? null : iconWidget.getWidgetStruct(), 
			Str.toStringz(label));

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_menu_tool_button_new");
		}

		this(cast(GtkMenuToolButton*) p);
	}
	
	/**
	 * Creates a new GtkMenuToolButton.
	 * The new GtkMenuToolButton will contain an icon and label from
	 * the stock item indicated by stockID.
	 * Since 2.6
	 * Params:
	 * stockID = the name of a stock item
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this(StockID stockId)
	{
		// GtkToolItem* gtk_menu_tool_button_new_from_stock  (const gchar *stock_id);
		auto p = gtk_menu_tool_button_new_from_stock(
			Str.toStringz(StockDesc[stockId]));

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_menu_tool_button_new_from_stock");
		}

		this(cast(GtkMenuToolButton*) p);
	}

	/**
	 * Gets the GtkMenu associated with GtkMenuToolButton.
	 * Since 2.6
	 * Params:
	 *  button = a GtkMenuToolButton
	 * Returns:
	 *  the GtkMenu associated with GtkMenuToolButton
	 */
	public Menu getMenu()
	{
		// GtkWidget* gtk_menu_tool_button_get_menu (GtkMenuToolButton *button);
		auto p =  gtk_menu_tool_button_get_menu(gtkMenuToolButton);
		if(p is null)
		{
			return null;
		}
		return new Menu(cast(GtkMenu*)p);
	}
	
	/**
	 * Sets the toolTip for the arrow
	 * Deprecated: Since 2.12 use Widget.setArrowTooltipText() or Widget.setArrowTooltipMarkup()
	 * Params:
	 *    	tipText = 	
	 *    	tipPrivate = 	
	 */
	public void setArrowTooltip(string tipText, string tipPrivate)
	{
		Tooltips tooltips = new Tooltips();
		gtk_menu_tool_button_set_arrow_tooltip(
			gtkMenuToolButton, 
			(tooltips is null) ? null : tooltips.getTooltipsStruct(), 
			Str.toStringz(tipText), 
			Str.toStringz(tipPrivate)
			);
	}

code: end

outFile: MenuToolButton

file: GtkToggleToolButton.html
struct: GtkToggleToolButton
ctorStruct: GtkToolItem
class: ToggleToolButton
prefix: gtk_toggle_tool_button_
prefix: gtk_
import: glib.Str
import: gtk.ToolItem
structWrap: GtkToolItem* ToolItem
outFile: ToggleToolButton

file: GtkRadioToolButton.html
struct: GtkRadioToolButton
ctorStruct: GtkToolItem
class: RadioToolButton
prefix: gtk_radio_tool_button_
prefix: gtk_
import: glib.Str
import: gtk.ToolItem
structWrap: GtkToolItem* ToolItem
import: glib.ListSG
structWrap: GSList* ListSG
structWrap: GtkRadioToolButton* RadioToolButton
outFile: RadioToolButton

###########################################################
### Action-based menus and toolbars #######################
###########################################################

file: GtkUIManager.html
struct: GtkUIManager
class: UIManager
implements: BuildableIF
prefix: gtk_ui_manager_
prefix: gtk_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gtk.ActionGroup
structWrap: GtkActionGroup* ActionGroup
import: glib.ListG
structWrap: GList* ListG
import: gtk.AccelGroup
structWrap: GtkAccelGroup* AccelGroup
import: gtk.Widget
structWrap: GtkWidget* Widget
import: glib.ListSG
structWrap: GSList* ListSG
import: gtk.Action
structWrap: GtkAction* Action
import: gobject.Type
import: gtk.CheckMenuItem
import: gtk.ImageMenuItem
import: gtk.Menu
import: gtk.MenuBar
import: gtk.MenuItem
import: gtk.MenuToolButton
import: gtk.RadioMenuItem
import: gtk.RadioToolButton
import: gtk.SeparatorMenuItem
import: gtk.SeparatorToolItem
import: gtk.TearoffMenuItem
import: gtk.ToggleToolButton
import: gtk.Toolbar
import: gtk.ToolButton
import: gtk.ToolItem

#imports for Buildable Interface.
import: gtk.BuildableIF
import: gtk.BuildableT

nocode: gtk_ui_manager_get_widget

code: start
	// add the Buildable capabilities
	mixin BuildableT!(GtkUIManager);

	/**
	 * Looks up a widget by following a path.
	 * The path consists of the names specified in the XML description of the UI.
	 * separated by '/'. Elements which don't have a name or action attribute in
	 * the XML (e.g. &lt;popup&gt;) can be addressed by their XML element name
	 * (e.g. "popup"). The root element ("/ui") can be omitted in the path.
	 * 
	 * Note that the widget found by following a path that ends in a &lt;menu&gt;
	 * element is the menuitem to which the menu is attached, not the menu itself.
	 * 
	 * Also note that the widgets constructed by a ui manager are not tied to
	 * the lifecycle of the ui manager. If you add the widgets returned by this
	 * function to some container or explicitly ref them, they will survive the
	 * destruction of the ui manager.
	 * 
	 * Since 2.4
	 * 
	 * Params:
	 *    path = a path
	 * 
	 * Returns: the widget found by following the path, or null if no widget was found.
	 */
	public Widget getWidget(string path)
	{
		// GtkWidget * gtk_ui_manager_get_widget (GtkUIManager *manager,  const gchar *path);
		auto p = gtk_ui_manager_get_widget(gtkUIManager, Str.toStringz(path));
		
		if(p is null)
		{
			return null;
		}
		
		string typeName = Type.name((cast(GTypeInstance*)p).gClass.gType);

		switch(typeName)
		{
			case "GtkCheckMenuItem":
				return ObjectG.getDObject!(CheckMenuItem)(cast(GtkCheckMenuItem*) p);
			case "GtkImageMenuItem":
				return ObjectG.getDObject!(ImageMenuItem)(cast(GtkImageMenuItem*) p);
			case "GtkMenu":
				return ObjectG.getDObject!(Menu)(cast(GtkMenu*) p);
			case "GtkMenuBar":
				return ObjectG.getDObject!(MenuBar)(cast(GtkMenuBar*) p);
			case "GtkMenuItem":
				return ObjectG.getDObject!(MenuItem)(cast(GtkMenuItem*) p);
			case "GtkMenuToolButton":
				return ObjectG.getDObject!(MenuToolButton)(cast(GtkMenuToolButton*) p);
			case "GtkRadioMenuItem":
				return ObjectG.getDObject!(RadioMenuItem)(cast(GtkRadioMenuItem*) p);
			case "GtkRadioToolButton":
				return ObjectG.getDObject!(RadioToolButton)(cast(GtkRadioToolButton*) p);
			case "GtkSeparatorMenuItem":
				return ObjectG.getDObject!(SeparatorMenuItem)(cast(GtkSeparatorMenuItem*) p);
			case "GtkSeparatorToolItem":
				return ObjectG.getDObject!(SeparatorToolItem)(cast(GtkSeparatorToolItem*) p);
			case "GtkTearoffMenuItem":
				return ObjectG.getDObject!(TearoffMenuItem)(cast(GtkTearoffMenuItem*) p);
			case "GtkToggleToolButton":
				return ObjectG.getDObject!(ToggleToolButton)(cast(GtkToggleToolButton*) p);
			case "GtkToolbar":
				return ObjectG.getDObject!(Toolbar)(cast(GtkToolbar*) p);
			case "GtkToolButton":
				return ObjectG.getDObject!(ToolButton)(cast(GtkToolButton*) p);
			case "GtkToolItem":
				return ObjectG.getDObject!(ToolItem)(cast(GtkToolItem*) p);
			default:
				return ObjectG.getDObject!(Widget)(cast(GtkWidget*) p);
		}
	}
code: end
outFile: UIManager

file: GtkActionGroup.html
struct: GtkActionGroup
class: ActionGroup
implements: BuildableIF
prefix: gtk_action_group_
prefix: gtk_
import: glib.Str
import: gtk.Action
structWrap: GtkAction* Action
import: glib.ListG
structWrap: GList* ListG
import: gtk.Widget
structWrap: GtkWidget* Widget
#import: gtk.ActionEntry
#structWrap: GtkActionEntry* ActionEntry
#import: gtk.ToggleActionEntry
#structWrap: GtkToggleActionEntry* ToggleActionEntry
#import: gtk.RadioActionEntry
#structWrap: GtkRadioActionEntry* RadioActionEntry

#imports for Buildable Interface.
import: gtk.BuildableIF
import: gtk.BuildableT

array: gtk_action_group_add_actions entries n_entries
array: gtk_action_group_add_actions_full entries n_entries
array: gtk_action_group_add_toggle_actions entries n_entries
array: gtk_action_group_add_toggle_actions_full entries n_entries
array: gtk_action_group_add_radio_actions entries n_entries
array: gtk_action_group_add_radio_actions_full entries n_entries

code: start
	// add the Buildable capabilities
	mixin BuildableT!(GtkActionGroup);
code: end
outFile: ActionGroup

file: GtkAction.html
struct: GtkAction
class: Action
implements: BuildableIF
prefix: gtk_action_
prefix: gtk_
import: glib.Str
import: gio.Icon
import: gio.IconIF
structWrap: GIcon* IconIF
import: gtk.Widget
structWrap: GtkWidget* Widget
import: glib.ListSG
structWrap: GSList* ListSG
import: gobject.Closure
structWrap: GClosure* Closure
import: gtk.AccelGroup
structWrap: GtkAccelGroup* AccelGroup
import: gtk.Image
import: gtk.Menu
import: gtk.MenuItem
import: gtk.ToolItem

#imports for Buildable Interface.
import: gtk.BuildableIF
import: gtk.BuildableT

nocode: gtk_action_get_stock_id
nocode: gtk_action_set_stock_id
nocode: gtk_action_create_icon
nocode: gtk_action_create_menu_item
nocode: gtk_action_create_tool_item
nocode: gtk_action_create_menu

code: start
	// add the Buildable capabilities
	mixin BuildableT!(GtkAction);

	/**
	 * Creates a new GtkAction object. To add the action to a
	 * GtkActionGroup and set the accelerator for the action,
	 * call gtk_action_group_add_action_with_accel().
	 * See the section called UI Definitions for information on allowed action
	 * names.
	 * Since 2.4
	 * Params:
	 * name =  A unique name for the action
	 * label =  the label displayed in menu items and on buttons, or NULL
	 * tooltip =  a tooltip for the action, or NULL
	 * stockId =  the stock icon to display in widgets representing the
	 *  action.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string name, string label, string tooltip, StockID stockId)
	{
		this(name, label, tooltip, StockDesc[stockId]);
	}

	/**
	 * Gets the stock id of action.
	 * Since 2.16
	 * Returns: the stock id
	 */
	public StockID getStockId()
	{
		// const gchar * gtk_action_get_stock_id (GtkAction *action);
		string id = Str.toString(gtk_action_get_stock_id(gtkAction));

		foreach(i, desc; StockDesc)
		{
			if(desc == id)
				return cast(StockID)i;
		}

		return StockID.DISCARD;
	}

	/**
	 * Sets the stock id on action
	 * Since 2.16
	 * Params:
	 * stockId =  the stock id
	 */
	public void setStockId(StockID stockId)
	{
		// void gtk_action_set_stock_id (GtkAction *action,  const gchar *stock_id);
		gtk_action_set_stock_id(gtkAction, Str.toStringz(StockDesc[stockId]));
	}

	/**
	 * This function is intended for use by action implementations to
	 * create icons displayed in the proxy widgets.
	 * Since 2.4
	 * Params:
	 * iconSize = the size of the icon that should be created. [type int]
	 * Returns: a widget that displays the icon for this action.
	 */
	public Image createIcon(GtkIconSize iconSize)
	{
		// GtkWidget * gtk_action_create_icon (GtkAction *action,  GtkIconSize icon_size);
		auto p = gtk_action_create_icon(gtkAction, iconSize);
		if(p is null)
		{
			return null;
		}
		return new Image(cast(GtkImage*) p);
	}
	
	/**
	 * Creates a menu item widget that proxies for the given action.
	 * Since 2.4
	 * Returns: a menu item connected to the action.
	 */
	public MenuItem createMenuItem()
	{
		// GtkWidget * gtk_action_create_menu_item (GtkAction *action);
		auto p = gtk_action_create_menu_item(gtkAction);
		if(p is null)
		{
			return null;
		}
		return new MenuItem(cast(GtkMenuItem*) p);
	}
	
	/**
	 * Creates a toolbar item widget that proxies for the given action.
	 * Since 2.4
	 * Returns: a toolbar item connected to the action.
	 */
	public ToolItem createToolItem()
	{
		// GtkWidget * gtk_action_create_tool_item (GtkAction *action);
		auto p = gtk_action_create_tool_item(gtkAction);
		if(p is null)
		{
			return null;
		}
		return new ToolItem(cast(GtkToolItem*) p);
	}
	
	/**
	 * If action provides a GtkMenu widget as a submenu for the menu
	 * item or the toolbar item it creates, this function returns an
	 * instance of that menu.
	 * Since 2.12
	 * Returns: the menu item provided by the action, or NULL.
	 */
	public Menu createMenu()
	{
		// GtkWidget * gtk_action_create_menu (GtkAction *action);
		auto p = gtk_action_create_menu(gtkAction);
		if(p is null)
		{
			return null;
		}
		return new Menu(cast(GtkMenu*) p);
	}
code: end
outFile: Action

file: GtkToggleAction.html
struct: GtkToggleAction
class: ToggleAction
prefix: gtk_toggle_action_
prefix: gtk_
import: glib.Str

code: start
/**
	 * Creates a new GtkToggleAction object. To add the action to
	 * a GtkActionGroup and set the accelerator for the action,
	 * call gtk_action_group_add_action_with_accel().
	 * Since 2.4
	 * Params:
	 * name =  A unique name for the action
	 * label =  The label displayed in menu items and on buttons, or NULL
	 * tooltip =  A tooltip for the action, or NULL
	 * stockId =  The stock icon to display in widgets representing the
	 *  action, or NULL
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string name, string label, string tooltip, StockID stockId)
	{
		this(name, label, tooltip, StockDesc[stockId]);
	}
code: end
outFile: ToggleAction

file: GtkRadioAction.html
struct: GtkRadioAction
class: RadioAction
prefix: gtk_radio_action_
prefix: gtk_
import: glib.Str
import: glib.ListSG
structWrap: GSList* ListSG

code: start
	/**
	 * Creates a new GtkRadioAction object. To add the action to
	 * a GtkActionGroup and set the accelerator for the action,
	 * call gtk_action_group_add_action_with_accel().
	 * Since 2.4
	 * Params:
	 * name =  A unique name for the action
	 * label =  The label displayed in menu items and on buttons, or NULL
	 * tooltip =  A tooltip for this action, or NULL
	 * stockId =  The stock icon to display in widgets representing this
	 *  action, or NULL
	 * value =  The value which gtk_radio_action_get_current_value() should
	 *  return if this action is selected.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string name, string label, string tooltip, StockID stockId, int value)
	{
		this(name, label, tooltip, StockDesc[stockId], value);
	}
code: end
outFile: RadioAction

file: GtkRecentAction.html
struct: GtkRecentAction
ctorStruct: GtkAction
class: RecentAction
prefix: gtk_recent_action_
prefix: gtk_
import: glib.Str
import: gtk.RecentManager
structWrap: GtkRecentManager* RecentManager

nocode: gtk_recent_action_new
nocode: gtk_recent_action_new_for_manager

code: start
	/**
	 * Creates a new GtkRecentAction object. To add the action to
	 * a GtkActionGroup and set the accelerator for the action,
	 * call gtk_action_group_add_action_with_accel().
	 * Since 2.12
	 * Params:
	 * name =  a unique name for the action
	 * label =  the label displayed in menu items and on buttons, or NULL
	 * tooltip =  a tooltip for the action, or NULL
	 * stockID =  the stock icon to display in widgets representing the
	 *  action, or NULL
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string name, string label, string tooltip, StockID stockID)
	{
		// GtkAction* gtk_recent_action_new (const gchar *name,  const gchar *label,  const gchar *tooltip,  const gchar *stock_id);
		auto p = gtk_recent_action_new(Str.toStringz(name), Str.toStringz(label), Str.toStringz(tooltip), Str.toStringz(StockDesc[stockID]));
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_recent_action_new");
		}
		this(cast(GtkRecentAction*) p);
	}
	
	/**
	 * Creates a new GtkRecentAction object. To add the action to
	 * a GtkActionGroup and set the accelerator for the action,
	 * call gtk_action_group_add_action_with_accel().
	 * Since 2.12
	 * Params:
	 * name =  a unique name for the action
	 * label =  the label displayed in menu items and on buttons, or NULL
	 * tooltip =  a tooltip for the action, or NULL
	 * stockID =  the stock icon to display in widgets representing the
	 *  action, or NULL
	 * manager =  a GtkRecentManager, or NULL for using the default
	 *  GtkRecentManager
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string name, string label, string tooltip, StockID stockID, RecentManager manager)
	{
		// GtkAction* gtk_recent_action_new_for_manager (const gchar *name,  const gchar *label,  const gchar *tooltip,  const gchar *stock_id,  GtkRecentManager *manager);
		auto p = gtk_recent_action_new_for_manager(Str.toStringz(name), Str.toStringz(label), Str.toStringz(tooltip), Str.toStringz(StockDesc[stockID]), (manager is null) ? null : manager.getRecentManagerStruct());
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_recent_action_new_for_manager");
		}
		this(cast(GtkRecentAction*) p);
	}
code: end
outFile: RecentAction

file: GtkActivatable.html
struct: GtkActivatable
class: ActivatableT
template: TStruct
prefix: gtk_activatable_
import: gtk.Action
structWrap: GtkAction* Action
interface: ActivatableIF
outFile: ActivatableT

###########################################################
###  Selectors (File/Font/Color/Input Devices) ############
###########################################################

file: GtkColorButton.html
struct: GtkColorButton
class: ColorButton
prefix: gtk_color_button_
prefix: gtk_
import: glib.Str
import: gdk.Color
structWrap: GdkColor* Color
outFile: ColorButton

file: GtkColorSelection.html
struct: GtkColorSelection
class: ColorSelection
prefix: gtk_color_selection_
prefix: gtk_
import: glib.Str
import: gdk.Color
structWrap: GdkColor* Color

out: gtk_color_selection_palette_from_string colors
array: gtk_color_selection_palette_from_string colors n_colors
array: gtk_color_selection_set_color color
array: gtk_color_selection_get_color color

outFile: ColorSelection

file: GtkColorSelectionDialog.html
struct: GtkColorSelectionDialog
class: ColorSelectionDialog
prefix: gtk_color_selection_dialog_
prefix: gtk_
import: glib.Str
import: gtk.Widget
import: gtk.ColorSelection
structWrap: GtkWidget* Widget

nocode: gtk_color_selection_dialog_get_color_selection
code: start
	/**
	 * Retrieves the GtkColorSelection widget embedded in the dialog.
	 * Since 2.14
	 * Returns: the embedded GtkColorSelection
	 */
	public ColorSelection getColorSelection()
	{
		// GtkWidget* gtk_color_selection_dialog_get_color_selection  (GtkColorSelectionDialog *colorsel);
		auto p = gtk_color_selection_dialog_get_color_selection(gtkColorSelectionDialog);
		if(p is null)
		{
			return null;
		}
		return new ColorSelection(cast(GtkColorSelection*) p);
	}
code: end
outFile: ColorSelectionDialog

file: GtkFileChooser.html
struct: GtkFileChooser
class: FileChooserT
template: TStruct
prefix: gtk_file_chooser_
prefix: gtk_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.File
structWrap: GFile* File
import: gtk.Window
structWrap: GtkWindow* Window
import: glib.ListSG
structWrap: GSList* ListSG
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.FileFilter
structWrap: GtkFileFilter* FileFilter

alias: setAction setFileChooserAction
alias: getAction getFileChooserAction

interface: FileChooserIF
outFile: FileChooserT

file: GtkFileChooserButton.html
struct: GtkFileChooserButton
class: FileChooserButton
implements: FileChooserIF
prefix: gtk_file_chooser_button_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget

# imports for FileChooser Interface
import: gtk.FileChooserT
import: gtk.FileChooserIF

code: start
	// add the FileChooser capabilities
	mixin FileChooserT!(GtkFileChooserButton);
cade: end
outFile: FileChooserButton

file: GtkFileChooserDialog.html
struct: GtkFileChooserDialog
class: FileChooserDialog
implements: FileChooserIF
prefix: gtk_file_chooser_dialog_
prefix: gtk_
import: glib.Str
import: gtk.Window

# imports for FileChooser Interface
import: gtk.FileChooserT
import: gtk.FileChooserIF

nocode: gtk_file_chooser_dialog_new
nocode: gtk_file_chooser_dialog_new_with_backend

code: start
	// add the FileChooser capabilities
	mixin FileChooserT!(GtkFileChooserDialog);

	/**
	 * Creates a new GtkFileChooserDialog. This function is analogous to
	 * gtk_dialog_new_with_buttons().
	 * Since 2.4
	 * Params:
	 *  title = Title of the dialog, or NULL
	 *  parent = Transient parent of the dialog, or NULL
	 *  action = Open or save mode for the dialog
	 *  buttonsText = text to go in the buttons
	 *  responses = response ID's for the buttons
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	this(string title, Window parent, FileChooserAction action,  string[] buttonsText=null, ResponseType[] responses=null)
	{
		if ( buttonsText  is  null )
		{
			buttonsText ~= "OK";
			buttonsText ~= "Cancel";
		}
		if ( responses  is  null )
		{
			responses ~= ResponseType.OK;
			responses ~= ResponseType.CANCEL;
		}

		auto p = gtk_file_chooser_dialog_new(
				Str.toStringz(title),
				parent.getWindowStruct(),
				action,
				null,
				0);

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_file_chooser_dialog_new");
		}

		this(cast(GtkFileChooserDialog*) p);

		addButtons(buttonsText, responses);
	}

	/**
	 * Creates a new GtkFileChooserDialog with a specified backend. This is
	 * especially useful if you use gtk_file_chooser_set_local_only() to allow
	 * non-local files and you use a more expressive vfs, such as gnome-vfs,
	 * to load files.
	 * Since 2.4
	 * Params:
	 *  title = Title of the dialog, or NULL
	 *  parent = Transient parent of the dialog, or NULL
	 *  action = Open or save mode for the dialog
	 *  backend = The name of the specific filesystem backend to use.
	 *  buttonsText = text to go in the buttons
	 *  responses = response ID's for the buttons
	 * See_Also:
	 *  GtkFileChooser, GtkDialog
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string title, Window parent, GtkFileChooserAction action, string backend,  string[] buttonsText=null, ResponseType[] responses=null)
	{
		// GtkWidget* gtk_file_chooser_dialog_new_with_backend  (const gchar *title,  GtkWindow *parent,  GtkFileChooserAction action,  const gchar *backend,  const gchar *first_button_text,  ...);
		auto p = gtk_file_chooser_dialog_new_with_backend(
				Str.toStringz(title), 
				parent.getWindowStruct(), 
				action, 
				Str.toStringz(backend), 
				null,
				0
				);

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_file_chooser_dialog_new_with_backend");
		}

		this(cast(GtkFileChooserDialog*) p);

		if ( buttonsText  is  null )
		{
			buttonsText ~= "OK";
			buttonsText ~= "Cancel";
		}
		if ( responses  is  null )
		{
			responses ~= ResponseType.OK;
			responses ~= ResponseType.CANCEL;
		}

		addButtons(buttonsText, responses);
	}
code: end
outFile: FileChooserDialog

file: GtkFileChooserWidget.html
struct: GtkFileChooserWidget
ctorStruct: GtkWidget
class: FileChooserWidget
prefix: gtk_file_chooser_widget_
prefix: gtk_
import: glib.Str

# imports for FileChooser Interface
import: gtk.FileChooserT
import: gtk.FileChooserIF

code: start
	// add the FileChooser capabilities
	mixin FileChooserT!(FileChooserWidget);
cade: end
outFile: FileChooserWidget

file: gtk-gtkfilefilter.html
struct:  GtkFileFilter
class: FileFilter
prefix: gtk_file_filter_
prefix: gtk_
import: glib.Str
outFile: FileFilter

file: GtkFontButton.html
struct: GtkFontButton
class: FontButton
prefix: gtk_font_button_
prefix: gtk_
import: glib.Str
outFile: FontButton

file: GtkFontSelection.html
struct: GtkFontSelection
class: FontSelection
prefix: gtk_font_selection_
prefix: gtk_
import: glib.Str
import: gdk.Font
structWrap: GdkFont* Font
import: gtk.Widget
structWrap: GtkWidget* Widget
import: pango.PgFontFace
structWrap: PangoFontFace* PgFontFace
import:  pango.PgFontFamily
structWrap: PangoFontFamily* PgFontFamily
outFile: FontSelection

file: GtkFontSelectionDialog.html
struct: GtkFontSelectionDialog
class: FontSelectionDialog
prefix: gtk_font_selection_dialog_
prefix: gtk_
import: glib.Str
import: gdk.Font
structWrap: GdkFont* Font
import: gtk.FontSelection
import: gtk.Widget
structWrap: GtkWidget* Widget
nocode: gtk_font_selection_dialog_get_font_selection
code: start
	/**
	 * Retrieves the GtkFontSelection widget embedded in the dialog.
	 * Since 2.22
	 * Returns: the embedded GtkFontSelection
	 */
	public FontSelection getFontSelection()
	{
		// GtkWidget * gtk_font_selection_dialog_get_font_selection  (GtkFontSelectionDialog *fsd);
		auto p = gtk_font_selection_dialog_get_font_selection(gtkFontSelectionDialog);
		if(p is null)
		{
			return null;
		}
		return new FontSelection(cast(GtkFontSelection*) p);
	}
code: end
outFile: FontSelectionDialog

file: GtkInputDialog.html
struct: GtkInputDialog
class: InputDialog
prefix: gtk_input_dialog_
prefix: gtk_
import: gtk.Button

code: start
	Button getCloseButton()
	{
		int* pt =cast(int*)getStruct();
		pt += 172/4;
		return new Button(cast(GtkButton*)(*pt));
	}

	Button getSaveButton()
	{
		int* pt =cast(int*)getStruct();
		pt += 176/4;
		return new Button(cast(GtkButton*)(*pt));
	}
code: end
outFile: InputDialog

###########################################################
### Layout Containers #####################################
###########################################################

file: GtkAlignment.html
struct: GtkAlignment
class: Alignment
prefix: gtk_alignment_
prefix: gtk_
import: gtk.Widget

out: gtk_alignment_get_padding padding_top
out: gtk_alignment_get_padding padding_bottom
out: gtk_alignment_get_padding padding_left
out: gtk_alignment_get_padding padding_right

code: start
	/** */
	public static Alignment center(Widget widget)
	{
		Alignment a = new Alignment(0.5, 0.5, 0, 0);
		a.add(widget);
		return a;
	}

	/** */	
	public static Alignment north(Widget widget)
	{
		Alignment a = new Alignment(0.5, 0.0, 0, 0);
		a.add(widget);
		return a;
	}

	/** */	
	public static Alignment south(Widget widget)
	{
		Alignment a = new Alignment(0.5, 1.0, 0, 0);
		a.add(widget);
		return a;
	}

	/** */	
	public static Alignment east(Widget widget)
	{
		Alignment a = new Alignment(1.0, 0.5, 0, 0);
		a.add(widget);
		return a;
	}
	
	/** */
	public static Alignment west(Widget widget)
	{
		Alignment a = new Alignment(0.0, 0.5, 0, 0);
		a.add(widget);
		return a;
	}

	/** */	
	public static Alignment northWest(Widget widget)
	{
		Alignment a = new Alignment(0.0, 0.0, 0, 0);
		a.add(widget);
		return a;
	}

	/** */
	public static Alignment southWest(Widget widget)
	{
		Alignment a = new Alignment(0.0, 0.5, 0, 0);
		a.add(widget);
		return a;
	}

	/** */
	public static Alignment northEast(Widget widget)
	{
		Alignment a = new Alignment(1.0, 0.0, 0, 0);
		a.add(widget);
		return a;
	}

	/** */
	public static Alignment southEast(Widget widget)
	{
		Alignment a = new Alignment(1.0, 1.0, 0, 0);
		a.add(widget);
		return a;
	}
code: end
outFile: Alignment

file: GtkAspectFrame.html
struct: GtkAspectFrame
class: AspectFrame
prefix: gtk_aspect_frame_
prefix: gtk_
import: glib.Str
outFile: AspectFrame

file: GtkHBox.html
struct: GtkHBox
class: HBox
prefix: gtk_hbox_
prefix: gtk_
outFile: HBox

file: GtkVBox.html
struct: GtkVBox
class: VBox
prefix: gtk_vbox_
prefix: gtk_
outFile: VBox

file: GtkHButtonBox.html
struct: GtkHButtonBox
class: HButtonBox
prefix: gtk_hbutton_box_
prefix: gtk_
code: start
	/**
	 * Creates a new HButtonBox and sets comon parameters
	 */
	static HButtonBox createActionBox()
	{
		HButtonBox bBox = new HButtonBox();
		bBox.setLayout(ButtonBoxStyle.END);
		bBox.setBorderWidth(5);
		bBox.setSpacing(7);
		return bBox;
	}
	
code: end
outFile: HButtonBox

file: GtkVButtonBox.html
struct: GtkVButtonBox
class: VButtonBox
prefix: gtk_vbutton_box_
prefix: gtk_
code: start
    /**
     * Creates a new vertical button box and sets standart values for it's comon parameters
     * Returns: a new vertical button box
     */
	static VButtonBox createActionBox()
	{
		VButtonBox bBox = new VButtonBox();
		bBox.setLayout(ButtonBoxStyle.START);
		bBox.setBorderWidth(5);
		bBox.setSpacing(7);
		return bBox;
	}
code: end
outFile: VButtonBox

file: GtkFixed.html
struct: GtkFixed
class: Fixed
prefix: gtk_fixed_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
override: getHasWindow
override: setHasWindow
outFile: Fixed

file: GtkHPaned.html
struct: GtkHPaned
class: HPaned
prefix: gtk_hpaned_
prefix: gtk_
structWrap: GtkWidget* Widget
import: gtk.Widget

code: start
	/**
	 * Creates a new HPaned and adds two widgets as it's children
	 * Params:
	 *  child1 =
	 *  child2 =
	 */
	this(Widget child1, Widget child2)
	{
		this();
		add1(child1);
		add2(child2);
	}
	
code: end
outFile: HPaned

file: GtkVPaned.html
struct: GtkVPaned
class: VPaned
prefix: gtk_vpaned_
prefix: gtk_
import: gtk.Widget

code: start
	/**
	 * Creates a new HPaned and adds two widgets as it's children
	 * Params:
	 *  child1 =
	 *  child2 =
	 */
	this(Widget child1, Widget child2)
	{
		this();
		add1(child1);
		add2(child2);
	}
	
code: end
outFile: VPaned

file: GtkLayout.html
struct: GtkLayout
class: Layout
prefix: gtk_layout_
prefix: gtk_
import: gdk.Window
structWrap: GdkWindow* Window
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
import: gtk.Widget
structWrap: GtkWidget* Widget

out: gtk_layout_get_size width
out: gtk_layout_get_size height

outFile: Layout

file: GtkNotebook.html
struct: GtkNotebook
class: Notebook
prefix: gtk_notebook_
prefix: gtk_
import: glib.Str
import: gtk.Label
import: gtk.Widget
structWrap: GtkWidget* Widget

out: gtk_notebook_query_tab_label_packing expand
out: gtk_notebook_query_tab_label_packing fill
out: gtk_notebook_query_tab_label_packing pack_type

code: start
/** The GtkNotebookTab is not documented */
public enum GtkNotebookTab
{
  GTK_NOTEBOOK_TAB_FIRST,
  GTK_NOTEBOOK_TAB_LAST
}
alias GtkNotebookTab NotebookTab;

	/**
	 * Append a page with a widget and a text for a label
	 */
	public int appendPage(Widget child, string tabLabel)
	{
		return appendPage(child, new Label(tabLabel));
	}

	/** */
	void setCurrentPage(Widget child)
	{
		gtk_notebook_set_current_page(gtkNotebook,gtk_notebook_page_num(gtkNotebook, child.getWidgetStruct()));
	}
code: end
outFile: Notebook

file: GtkTable.html
struct: GtkTable
class: Table
import: gtk.Widget
structWrap: GtkWidget* Widget
prefix: gtk_table_
prefix: gtk_

out: gtk_table_get_size rows
out: gtk_table_get_size columns
nocode: gtk_table_new

code: start

	int row;
	int col;
	int maxRows;
	int maxCols;

	public AttachOptions defaultXOption = AttachOptions.SHRINK;
	public AttachOptions defaultYOption = AttachOptions.SHRINK;
	
	/**
	 * Removes all children and resizes the table to 1,1
	 */
	override void removeAll()
	{
		super.removeAll();
		resize(1,1);
	}
	
	/**
	 * Used to create a new table widget. An initial size must be given by
	 * specifying how many rows and columns the table should have, although
	 * this can be changed later with gtk_table_resize(). rows and columns
	 * must both be in the range 0 .. 65535.
	 * Params:
	 *  rows = The number of rows the new table should have.
	 *  columns = The number of columns the new table should have.
	 *  homogeneous = If set to TRUE, all table cells are resized to the size of the cell
	 *  containing the largest widget.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (uint rows, uint columns, int homogeneous)
	{
		// GtkWidget* gtk_table_new (guint rows,  guint columns,  gboolean homogeneous);
		auto p = gtk_table_new(rows, columns, homogeneous);

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_table_new");
		}

		this(cast(GtkTable*) p);

		row = 0;
		col = 0;
		maxRows = rows;
		maxCols = columns;
	}
	

	/**
	 * Attach a new widget creating a new row if necessary
	 */
	void attach(Widget child)
	{
		attach(child, col, col + 1, row, row + 1,
				defaultXOption, defaultYOption,
				getDefaultColSpacing(), getDefaultRowSpacing());
		++col;
		if (col >= maxCols)
		{
			col = 0;
			++row;
		}
	}
code: end
outFile: Table

file: GtkExpander.html
struct: GtkExpander
class: Expander
prefix: gtk_expander_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget

nocode: gtk_expander_new
nocode: gtk_expander_new_with_mnemonic

code: start
	/**
	 * Creates a new expander using label as the text of the label.
	 * Since 2.4
	 * Params:
	 *  label = the text of the label
	 *  mnemonic = if true characters in label that are preceded by an underscore,
	 *  are underlined.
	 *  If you need a literal underscore character in a label, use '__' (two
	 *  underscores). The first underlined character represents a keyboard
	 *  accelerator called a mnemonic.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string label, bool mnemonic=true)
	{
		GtkExpander* p;

		if ( mnemonic )
		{
			// GtkWidget* gtk_expander_new_with_mnemonic (const gchar *label);
			p = cast(GtkExpander*)gtk_expander_new_with_mnemonic(Str.toStringz(label));
		}
		else
		{
			// GtkWidget* gtk_expander_new (const gchar *label);
			p = cast(GtkExpander*)gtk_expander_new(Str.toStringz(label));
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_expander_new");
		}

		this(p);
	}
code: end

outFile: Expander

file: gtk-Orientable.html
struct: GtkOrientable
class: OrientableT
template: TStruct
prefix: gtk_orientable_
interface: OrientableIF
outFile: OrientableT

###########################################################
### Ornaments #############################################
###########################################################

file: GtkFrame.html
struct: GtkFrame
class: Frame
prefix: gtk_frame_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget

out: gtk_frame_get_label_align xalign
out: gtk_frame_get_label_align yalign

code: start
	/**
	 * Creates frame with label and set it's child widget
	 */
	public this(Widget widget, string label)
	{
		this(label);
		add(widget);
	}
code: end

outFile: Frame

file: GtkHSeparator.html
struct: GtkHSeparator
class: HSeparator
prefix: gtk_hseparator_
prefix: gtk_
outFile: HSeparator

file: GtkVSeparator.html
struct: GtkVSeparator
class: VSeparator
prefix: gtk_vseparator_
prefix: gtk_
outFile: VSeparator

###########################################################
### Scrolling #############################################
###########################################################

file: GtkHScrollbar.html
struct: GtkHScrollbar
class: HScrollbar
prefix: gtk_hscrollbar_
prefix: gtk_
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: HScrollbar

file: GtkVScrollbar.html
struct: GtkVScrollbar
class: VScrollbar
prefix: gtk_vscrollbar_
prefix: gtk_
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: VScrollbar

file: GtkScrolledWindow.html
struct: GtkScrolledWindow
class: ScrolledWindow
prefix: gtk_scrolled_window_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment

out: gtk_scrolled_window_get_policy hscrollbar_policy
out: gtk_scrolled_window_get_policy vscrollbar_policy

nocode: gtk_scrolled_window_new

code: start
	/** */
	public this()
	{
		this(null, null);
	}

	/** */
	public this(Widget widget)
	{
		this();
		addWithViewport(widget);
	}
	
	/**
	 * Creates a new scrolled window. The two arguments are the scrolled
	 * window's adjustments; these will be shared with the scrollbars and the
	 * child widget to keep the bars in sync with the child. Usually you want
	 * to pass NULL for the adjustments, which will cause the scrolled window
	 * to create them for you.
	 * Params:
	 *  hadjustment = Horizontal adjustment.
	 *  vadjustment = Vertical adjustment.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (Adjustment hadjustment, Adjustment vadjustment)
	{
		// GtkWidget* gtk_scrolled_window_new (GtkAdjustment *hadjustment,  GtkAdjustment *vadjustment);
		auto p = gtk_scrolled_window_new(
				hadjustment is null ? null : hadjustment.getAdjustmentStruct(), 
				vadjustment is null ? null : vadjustment.getAdjustmentStruct());

		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_scrolled_window_new");
		}

		this(cast(GtkScrolledWindow*) p);
	}

	/**
	 * Creates a new Scrolled window and set the policy type
	 * Params:
	 *  hPolicy = the horizontal policy
	 *  vPolicy = the vertical policy
	 */
	this(PolicyType hPolicy, PolicyType vPolicy)
	{
		this();
		setPolicy(hPolicy, vPolicy);
	}
code: end
outFile: ScrolledWindow

###########################################################
### Printing ##############################################
###########################################################

file: gtk-High-level-Printing-API.html
struct: GtkPrintOperation
class: PrintOperation
implements: PrintOperationPreviewIF
prefix: gtk_print_operation_
noprefix: gtk_print_operation_preview_
nosignal: got-page-size 
nosignal: ready
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Window
structWrap: GtkWindow* Window
import: gtk.PageSetup
structWrap: GtkPageSetup* PageSetup
import: gtk.PrintContext
structWrap: GtkPrintContext* PrintContext
import: gtk.PrintSettings
structWrap: GtkPrintSettings* PrintSettings
import: glib.ErrorG
import: glib.GException

#imports for PrintOperationPreview Interface.
import: gtk.PrintOperationPreviewT
import: gtk.PrintOperationPreviewIF
#import: gtk.Widget
#import: gtk.PageSetup
#import: gtk.PrintSettings

code: start
	// add the PrintOperationPreview capabilities
	mixin PrintOperationPreviewT!(GtkPrintOperation);
code: end
outFile: PrintOperation

struct: GtkPrintOperationPreview
class: PrintOperationPreviewT
template: TStruct
strictPrefix: Y
nosignal: begin-print
nosignal: create-custom-widget
nosignal: custom-widget-apply
nosignal: done
nosignal: draw-page
nosignal: end-print
nosignal: paginate
nosignal: preview
nosignal: request-page-setup 
nosignal: status-changed
prefix: gtk_print_operation_preview_
#prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.PageSetup
structWrap: GtkPageSetup* PageSetup
import: gtk.PrintSettings
structWrap: GtkPrintSettings* PrintSettings
interface: PrintOperationPreviewIF
outFile: PrintOperationPreviewT

file: GtkPrintContext.html
struct: GtkPrintContext
class: PrintContext
prefix: gtk_print_context_
prefix: gtk_
import: cairo.Context
structWrap: cairo_t* Context
import: pango.PgContext
structWrap: PangoContext* PgContext
import: pango.PgFontMap
structWrap: PangoFontMap* PgFontMap
import: pango.PgLayout
structWrap: PangoLayout* PgLayout
import: gtk.PageSetup
structWrap: GtkPageSetup* PageSetup

out: gtk_print_context_get_hard_margins top
out: gtk_print_context_get_hard_margins bottom
out: gtk_print_context_get_hard_margins left
out: gtk_print_context_get_hard_margins right
outFile: PrintContext

file: GtkPrintSettings.html
struct: GtkPrintSettings
class: PrintSettings
prefix: gtk_print_settings_
prefix: gtk_
import: glib.Str
import: gtk.PaperSize
structWrap: GtkPaperSize* PaperSize
structWrap: GtkPrintSettings* PrintSettings
import: glib.ErrorG
import: glib.GException
import: glib.KeyFile
structWrap: GKeyFile* KeyFile

array: gtk_print_settings_get_page_ranges Return num_ranges
array: gtk_print_settings_set_page_ranges page_ranges num_ranges

outFile: PrintSettings

file: GtkPageSetup.html
struct: GtkPageSetup
class: PageSetup
prefix: gtk_page_setup_
prefix: gtk_
import: glib.Str
import: gtk.PaperSize
structWrap: GtkPaperSize* PaperSize
structWrap: GtkPageSetup* PageSetup
import: glib.ErrorG
import: glib.GException
import: glib.KeyFile
structWrap: GKeyFile* KeyFile
outFile: PageSetup

file: GtkPaperSize.html
struct: GtkPaperSize
class: PaperSize
prefix: gtk_paper_size_
prefix: gtk_
import: glib.Str
structWrap: GtkPaperSize* PaperSize
import: glib.ErrorG
import: glib.GException
import: glib.KeyFile
structWrap: GKeyFile* KeyFile
import: glib.ListG
structWrap: GList* ListG
outFile: PaperSize

file: GtkPrinter.html
struct: GtkPrinter
class: Printer
prefix: gtk_printer_
prefix: gtk_
import: glib.Str
structWrap: GtkPrinter* Printer
import: gtk.PageSetup
structWrap: GtkPageSetup* PageSetup
import: glib.ListG
structWrap: GList* ListG

out: gtk_printer_get_hard_margins top
out: gtk_printer_get_hard_margins bottom
out: gtk_printer_get_hard_margins left
out: gtk_printer_get_hard_margins right
outFile: Printer

file: GtkPrintJob.html
struct: GtkPrintJob
class: PrintJob
prefix: gtk_print_job_
prefix: gtk_
import: glib.Str
import: cairo.Surface
structWrap: cairo_surface_t* Surface
import: gtk.Printer
structWrap: GtkPrinter* Printer
import: gtk.PageSetup
structWrap: GtkPageSetup* PageSetup
import: gtk.PrintSettings
structWrap: GtkPrintSettings* PrintSettings
import: glib.ErrorG
import: glib.GException
outFile: PrintJob

file: GtkPrintUnixDialog.html
struct: GtkPrintUnixDialog
class: PrintUnixDialog
prefix: gtk_print_unix_dialog_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Window
structWrap: GtkWindow* Window
import: gtk.Printer
structWrap: GtkPrinter* Printer
import: gtk.PageSetup
structWrap: GtkPageSetup* PageSetup
import: gtk.PrintSettings
structWrap: GtkPrintSettings* PrintSettings

alias: setSettings setPrintSettings
alias: getSettings getPrintSettings
outFile: PrintUnixDialog

file: GtkPageSetupUnixDialog.html
struct: GtkPageSetupUnixDialog
class: PageSetupUnixDialog
prefix: gtk_page_setup_unix_dialog_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Window
structWrap: GtkWindow* Window
import: gtk.PageSetup
structWrap: GtkPageSetup* PageSetup
import: gtk.PrintSettings
structWrap: GtkPrintSettings* PrintSettings
outFile: PageSetupUnixDialog

###########################################################
### Miscellaneous #########################################
###########################################################

file: GtkAdjustment.html
struct: GtkAdjustment
class: Adjustment
prefix: gtk_adjustment_
prefix: gtk_
import: gtk.ObjectGtk
structWrap: GtkObject* ObjectGtk
outFile: Adjustment

file: GtkArrow.html
struct: GtkArrow
class: Arrow
prefix: gtk_arrow_
prefix: gtk_
outFile: Arrow

file: GtkCalendar.html
struct: GtkCalendar
class: Calendar
prefix: gtk_calendar_
prefix: gtk_

out: gtk_calendar_get_date year
out: gtk_calendar_get_date month
out: gtk_calendar_get_date day

outFile: Calendar

file: GtkDrawingArea.html
struct: GtkDrawingArea
class: DrawingArea
prefix: gtk_drawing_area_
prefix: gtk_

code: start
	/**
	 * Create a new DrawingArea and sets the SizeRequest
	 * Params:
	 *    	width = 	
	 *    	height =
	 */
	this(int width, int height)
	{
		this();
		setSizeRequest(width, height);
	}
	
code: end

outFile: DrawingArea

file: GtkEventBox.html
struct: GtkEventBox
class: EventBox
prefix: gtk_event_box_
prefix: gtk_
outFile: EventBox

file: GtkHandleBox.html
struct: GtkHandleBox
class: HandleBox
prefix: gtk_handle_box_
prefix: gtk_
outFile: HandleBox

file: GtkIMContextSimple.html
struct: GtkIMContextSimple
class: IMContextSimple
prefix: gtk_im_context_simple_
prefix: gtk_
import: gtk.IMContext
structWrap: GtkIMContext* IMContext
array: gtk_im_context_simple_add_table data n_seqs
outFile: IMContextSimple

file: GtkIMMulticontext.html
struct: GtkIMMulticontext
class: IMMulticontext
prefix: gtk_im_multicontext_
prefix: gtk_
import: glib.Str
import: gtk.IMContext
structWrap: GtkIMContext* IMContext
import: gtk.MenuShell
structWrap: GtkMenuShell* MenuShell
outFile: IMMulticontext

file: GtkSizeGroup.html
struct: GtkSizeGroup
class: SizeGroup
implements: BuildableIF
prefix: gtk_size_group_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
import: glib.ListSG
structWrap: GSList* ListSG

#imports for Buildable Interface.
import: gtk.BuildableIF
import: gtk.BuildableT

code: start
	// add the Buildable capabilities
	mixin BuildableT!(GtkSizeGroup);
code: end
outFile: SizeGroup

file: GtkTooltip.html
struct: GtkTooltip
class: Tooltip
prefix: gtk_tooltip_
prefix: gtk_
import: glib.Str
import: gio.IconIF
structWrap: GIcon* IconIF
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gdk.Display
structWrap: GdkDisplay* Display
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: Tooltip

file: GtkViewport.html
struct: GtkViewport
class: Viewport
prefix: gtk_viewport_
prefix: gtk_
import: gdk.Window
structWrap: GdkWindow* Window
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: Viewport

file: GtkAccessible.html
struct: GtkAccessible
class: Accessible
prefix: gtk_accessible_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: Accessible

###########################################################
### Abstract Base Classes #################################
###########################################################

file: GtkBin.html
struct: GtkBin
class: Bin
prefix: gtk_bin_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: Bin

file: GtkBox.html
struct: GtkBox
class: Box
implements: OrientableIF
prefix: gtk_box_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT

out: gtk_box_query_child_packing expand
out: gtk_box_query_child_packing fill
out: gtk_box_query_child_packing padding
out: gtk_box_query_child_packing pack_type

code: start
	// add the Orientable capabilities
	mixin OrientableT!(GtkBox);
code: end
outFile: Box

file: GtkButtonBox.html
struct: GtkButtonBox
class: ButtonBox
prefix: gtk_button_box_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Button
import: gtk.HButtonBox
import: gtk.VButtonBox

out: gtk_button_box_get_child_size min_width
out: gtk_button_box_get_child_size min_height
out: gtk_button_box_get_child_ipadding ipad_x
out: gtk_button_box_get_child_ipadding ipad_y

code: start
	/** */
	static ButtonBox createActionBox(
			void delegate(Button) onClicked, 
			StockID[] stocks, 
			string[] actions,
			bool vertical=false
		)
	{
		ButtonBox bBox;
		if ( vertical )
		{
			bBox = VButtonBox.createActionBox();
		}
		else
		{
			bBox = HButtonBox.createActionBox();
		}

		Button button;
		for( int i=0 ; i<stocks.length && i<actions.length ; i++)
		{
			button =  new Button(stocks[i]);
			bBox.packEnd(button, false, false, 7);
			button.setActionName(actions[i]);
			button.addOnClicked(onClicked);
		}
		return bBox;
	}

	/** */
	static ButtonBox createOkBox(void delegate(Button) onClicked)
	{
		static StockID[] stocks = [StockID.OK];
		string[] actions;
		actions ~= "action.ok";
		return createActionBox(onClicked, stocks, actions);
	}

	/** */
	static ButtonBox createOkCancelBox(void delegate(Button) onClicked)
	{
		static StockID[] stocks = [StockID.OK, StockID.CANCEL];
		string[] actions;
		actions ~= "action.ok";
		actions ~= "action.cancel";
		return createActionBox(onClicked, stocks, actions);
	}
code: end
outFile: ButtonBox

file: GtkContainer.html
struct: GtkContainer
class: Container
structWrap: GtkContainerClass* Container
structWrap: GtkWidget* Widget
import: glib.Str
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
prefix: gtk_container_
prefix: gtk_
import: glib.ListG
structWrap: GList* ListG
import: gobject.Value
structWrap: GValue* Value
#import: gdk.EventExpose
#structWrap: GdkEventExpose* EventExpose
import: gobject.ParamSpec
structWrap: GParamSpec* ParamSpec
#import: g.ObjectClass
#structWrap: GObjectClass* ObjectClass

out: gtk_container_get_focus_chain focusable_widgets
array: gtk_container_class_list_child_properties Return n_properties

code: start

	/**
	 * Removes all widgets from the container
	 */
	void removeAll()
	{
		GList* gList = gtk_container_get_children(getContainerStruct());
		if ( gList !is null )
		{
			ListG children = new ListG(gList);
			for ( int i=children.length()-1 ; i>=0 ; i-- )
			{
				gtk_container_remove(getContainerStruct(), cast(GtkWidget*)children.nthData(i));
			}
		}
	}

code: end
outFile: Container

file: GtkItem.html
struct: GtkItem
class: Item
prefix: gtk_item_
prefix: gtk_
outFile: Item

file: GtkMenuShell.html
struct: GtkMenuShell
class: MenuShell
prefix: gtk_menu_shell_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
outFile: MenuShell

file: GtkMisc.html
struct: GtkMisc
class: Misc
prefix: gtk_misc_
prefix: gtk_

out: gtk_misc_get_alignment xalign
out: gtk_misc_get_alignment yalign
out: gtk_misc_get_padding xpad
out: gtk_misc_get_padding ypad

outFile: Misc

file: GtkObject.html
struct: GtkObject
class: ObjectGtk
prefix: gtk_object_
prefix: gtk_
import: glib.Str
import: gtk.ObjectGtk
structWrap: GtkObject* ObjectGtk

nocode: gtk_object_ref
nocode: gtk_object_unref
nocode: gtk_object_set_data
nocode: gtk_object_get_data
nocode: gtk_object_set_data_full
nocode: gtk_object_remove_data

code: star
	/** */
	public static string getId(StockID id)
	{
		return StockDesc[id];
	}
code: end

outFile: ObjectGtk

file: GtkPaned.html
struct: GtkPaned
class: Paned
implements: OrientableIF
prefix: gtk_paned_
prefix: gtk_
import: gdk.Window
structWrap: GdkWindow* Window
import: gtk.Widget
structWrap: GtkWidget* Widget

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT

code: start
	// add the Orientable capabilities
	mixin OrientableT!(GtkPaned);

	/** */
	public void add(Widget child1, Widget child2)
	{
		add1(child1);
		add2(child2);
	}
code: end
outFile: Paned

file: GtkRange.html
struct: GtkRange
class: Range
implements: OrientableIF
prefix: gtk_range_
prefix: gtk_
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment

out: gtk_range_get_slider_range slider_start
out: gtk_range_get_slider_range slider_end

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT

code: start
	// add the Orientable capabilities
	mixin OrientableT!(GtkRange);
code: end
outFile: Range

file: GtkScale.html
struct: GtkScale
class: Scale
prefix: gtk_scale_
prefix: gtk_
import: glib.Str
import: pango.PgLayout
structWrap: PangoLayout* PgLayout

out: gtk_scale_get_layout_offsets x
out: gtk_scale_get_layout_offsets y

outFile: Scale

file: GtkScrollbar.html
struct: GtkScrollbar
class: Scrollbar
prefix: gtk_scrollbar_
prefix: gtk_
outFile: Scrollbar

file: GtkSeparator.html
struct: GtkSeparator
class: Separator
implements: OrientableIF
prefix: gtk_separator
prefix: gtk_

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT

code: start
	// add the Orientable capabilities
	mixin OrientableT!(GtkSeparator);
code: end
outFile: Separator

file: GtkWidget.html
struct: GtkWidget
nostruct: GtkWidgetClass
class: Widget
implements: BuildableIF
import: glib.Str
import: atk.ObjectAtk
structWrap: AtkObject* ObjectAtk
prefix: gtk_widget_
prefix: gtk_
# This function is exactly the same as calling g_object_ref(), and exists mostly for historical reasons.
noprefix: gtk_widget_ref
structWrap: GtkWidget* Widget
import: gtk.Action
structWrap: GtkAction* Action 
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle
#import: gtk.Requisition
#structWrap: GtkRequisition* Requisition
#import: gtk.Allocation
#structWrap: GtkAllocation* Allocation
import: gtk.AccelGroup
structWrap: GtkAccelGroup* AccelGroup
import: glib.ListG
structWrap: GList* ListG
import: gdk.Event
structWrap: GdkEvent* Event
import: gdk.Window
structWrap: GdkWindow* Window
import: gdk.Colormap
structWrap: GdkColormap* Colormap
import: gdk.Visual
structWrap: GdkVisual* Visual
import: gtk.Style
structWrap: GtkStyle* Style
import: gdk.Bitmap
structWrap: GdkBitmap* Bitmap
import: gdk.Pixmap
structWrap: GdkPixmap* Pixmap
import: gtk.RcStyle
structWrap: GtkRcStyle* RcStyle
import: gdk.Color
structWrap: GdkColor* Color
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
#import: gtk.WidgetClass
#structWrap: GtkWidgetClass* WidgetClass
import: gobject.ParamSpec
structWrap: GParamSpec* ParamSpec
import: gdk.Region
structWrap: GdkRegion* Region
import: gobject.Value
structWrap: GValue* Value
import: gtk.Settings
structWrap: GtkSettings* Settings
import: gtk.Clipboard
structWrap: GtkClipboard* Clipboard
import: gdk.Display
structWrap: GdkDisplay* Display
import: gdk.Screen
structWrap: GdkScreen* Screen
import: gtkc.gdk
import: gdk.Cursor

import: pango.PgLayout
structWrap: PangoLayout* PgLayout
import: pango.PgContext
structWrap: PangoContext* PgContext
import: pango.PgFontDescription
structWrap: PangoFontDescription* PgFontDescription
import: gdk.Drawable
import: gtk.Tooltips
import: gobject.Type
import: std.conv

#imports for Buildable Interface.
import: gtk.BuildableIF
import: gtk.BuildableT

nocode: gtk_widget_destroy

# New in 2.14, keep using the manually added ones for backwards compatibility.
nocode: gtk_widget_get_window
nocode: gtk_widget_get_allocation

override: unref
override: destroy
override: set

inout: gtk_widget_destroyed widget_pointer
out: gtk_widget_get_size_request width
out: gtk_widget_get_size_request height
out: gtk_widget_translate_coordinates dest_x
out: gtk_widget_translate_coordinates dest_y
out: gtk_widget_size_request requisition
out: gtk_widget_get_child_requisition requisition
out: gtk_widget_get_pointer x
out: gtk_widget_get_pointer y
array: gtk_widget_class_list_style_properties Return n_properties
out: gtk_widget_path path_length
out: gtk_widget_path path
out: gtk_widget_path path_reversed
out: gtk_widget_class_path path_length
out: gtk_widget_class_path path
out: gtk_widget_class_path path_reversed
inout: gtk_widget_set_allocation allocation
out: gtk_widget_get_requisition requisition

code: start
	// add the Buildable capabilities
	mixin BuildableT!(GtkWidget);

	public GtkWidgetClass* getWidgetClass()
	{
		return Type.getInstanceClass!(GtkWidgetClass)(this);
	}

	/** */
	public int getWidth()
	{
		int width;
		gtk_widget_get_size_request(gtkWidget, &width, null);
		return width;
	}

	/** */
	public int getHeight()
	{
		int height;
		gtk_widget_get_size_request(gtkWidget, null, &height);
		return height;
	}

	/**
	 * The widget's allocated size.
	 * Returns: the GtkAllocation for this widget
	 */
	public GtkAllocation getAllocation()
	{
		GtkAllocation allo;
		int* pt = cast(int*)getStruct();

		version (X86_64)
		{
			pt += 64/4; 
		}
		else
		{ 
			pt += 36/4;
		} 

		allo.x = *pt;

		pt++;
		allo.y = *pt;

		pt++;
		allo.width = *pt;

		pt++;
		allo.height = *pt;

		return allo;
	}

	/**
	 * Gets the drawable for this widget
	 * Returns:
	 * 		The drawable for this widget
	 * Deprecated: use getWindow().
	 */
	deprecated Drawable getDrawable()
	{
		return getWindow();
	}

	/**
	 * Gets the Window for this widget
	 * Returns:
	 * 		The window for this widget
	 */
	Window getWindow()
	{
		
		//		ubyte *p = cast(ubyte*)getStruct();
		//
		//		for ( int i=0 ; i<120 ; i+=4 )
		//		{
			//			printf("(%d) %X %x %x %x %x\n", i,p,*(p+0), *(p+1), *(p+2), *(p+3));
			//			p+=4;
		//		}
		//
		//		int* pt =cast(int*)getStruct();
		//
		//		printf("pt=%X strcut=%X\n", pt, getStruct());
		//		printf("*pt=%X\n", *pt);
		//		pt+=52/4;
		//		printf("pt+52=%X strcut.window=%X\n", pt, getWidgetStruct().window);
		//		printf("*pt+52=%X\n", *pt);
		//
		//		//return new Drawable(cast(GdkDrawable*)(getWidgetStruct().window));
		int* pt =cast(int*)getStruct();

		version (X86_64)
		{
			pt += 80/4; 
		}
		else
		{ 
			pt += 52/4; 
		} 

		return new Window(cast(GdkWindow*)(*pt));
	}

	/**
	 * Sets  the cursor.
	 * Params:
	 *  cursor = the new cursor
	 * Bugs: the cursor changes to the parent widget also
	 */
	void setCursor(Cursor cursor)
	{
		getWindow().setCursor(cursor);
	}
	
	/**
	 * Resets the cursor.
	 * don't know if this is implemented by GTK+. Seems that it's not
	 * Bugs: does nothing
	 */
	public void resetCursor()
	{
		getWindow().setCursor(null);
	}

	/**
	 * Modifies the font for this widget.
	 * This just calls modifyFont(new PgFontDescription(PgFontDescription.fromString(family ~ " " ~ size)));
	 */
	public void modifyFont(string family, int size)
	{
		if ( size < 0 ) size = -size;	// hack to workaround leds bug - TO BE REMOVED

		version(Tango)
		{
			char[10] s;
			modifyFont(
				PgFontDescription.fromString(
					family ~ " " ~ tango.text.convert.Integer.itoa(s,size)
				)
			);
		}
		else version(D_Version2)
		{
			modifyFont(
				PgFontDescription.fromString(
					family ~ " " ~ to!(string)(size)
				)
			);
		}
		else
		{
			modifyFont(
				PgFontDescription.fromString(
					family ~ " " ~ std.string.toString(size)
				)
			);
		}
	}
	
	
	/**
	 * Sets this widget tooltip
	 * Deprecated: Since 2.12 use setTooltipText() or setTooltipMarkup()
	 * Params:
	 *  tipText = the tooltip
	 *  tipPrivate = a private text
	 */
	void setTooltip(string tipText, string tipPrivate)
	{
		Tooltips tt = new Tooltips();
		tt.setTip(this, tipText, tipPrivate);
	}

	/** */
	public bool onEvent(GdkEvent* event)
	{
		return getWidgetClass().event(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onButtonPressEvent(GdkEventButton* event)
	{
		return getWidgetClass().buttonPressEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onButtonReleaseEvent(GdkEventButton* event)
	{
		return getWidgetClass().buttonReleaseEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onScrollEvent(GdkEventScroll* event)
	{
		return getWidgetClass().scrollEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onMotionNotifyEvent(GdkEventMotion* event)
	{
		return getWidgetClass().motionNotifyEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onDeleteEvent(GdkEventAny* event)
	{
		return getWidgetClass().deleteEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onExposeEvent(GdkEventExpose* event)
	{
		return getWidgetClass().exposeEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onKeyPressEvent(GdkEventKey* event)
	{
		return getWidgetClass().keyPressEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onKeyReleaseEvent(GdkEventKey* event)
	{
		return getWidgetClass().keyReleaseEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onEnterNotifyEvent(GdkEventCrossing* event)
	{
		return getWidgetClass().enterNotifyEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onLeaveNotifyEvent(GdkEventCrossing* event)
	{
		return getWidgetClass().leaveNotifyEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onConfigureEvent(GdkEventConfigure* event)
	{
		return getWidgetClass().configureEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onFocusInEvent(GdkEventFocus* event)
	{
		return getWidgetClass().focusInEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onFocusOutEvent(GdkEventFocus* event)
	{
		return getWidgetClass().focusOutEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onMapEvent(GdkEventAny* event)
	{
		return getWidgetClass().mapEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onUnmapEvent(GdkEventAny* event)
	{
		return getWidgetClass().unmapEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onPropertyNotifyEvent(GdkEventProperty* event)
	{
		return getWidgetClass().propertyNotifyEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onSelectionClearEvent(GdkEventSelection* event)
	{
		return getWidgetClass().selectionClearEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onSelectionRequestEvent(GdkEventSelection* event)
	{
		return getWidgetClass().selectionRequestEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onSelectionNotifyEvent(GdkEventSelection* event)
	{
		return getWidgetClass().selectionNotifyEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onProximityInEvent(GdkEventProximity* event)
	{
		return getWidgetClass().proximityInEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onProximityOutEvent(GdkEventProximity* event)
	{
		return getWidgetClass().proximityOutEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onVisibilityNotifyEvent(GdkEventVisibility* event)
	{
		return getWidgetClass().visibilityNotifyEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onClientEvent(GdkEventClient* event)
	{
		return getWidgetClass().clientEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onNoExposeEvent(GdkEventAny* event)
	{
		return getWidgetClass().noExposeEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/** */
	public bool onWindowStateEvent(GdkEventWindowState* event)
	{
		return getWidgetClass().windowStateEvent(getWidgetStruct(), event) == 0 ? false : true;
	}

	/**
	 * Destroys a widget.
	 *
	 * When a widget is destroyed, it will break any references it holds to
	 * other objects.
	 * If the widget is inside a container, the widget will be removed
	 * from the container. If the widget is a toplevel (derived from
	 * GtkWindow), it will be removed from the list of toplevels, and the
	 * reference GTK+ holds to it will be removed. Removing a
	 * widget from its container or the list of toplevels results in the
	 * widget being finalized, unless you've added additional references
	 * to the widget with g_object_ref().
	 * In most cases, only toplevel widgets (windows) require explicit
	 * destruction, because when you destroy a toplevel its children will
	 * be destroyed as well.
	 */
	public override void destroy()
	{
		// void gtk_widget_destroy (GtkWidget *widget);
		gtk_widget_destroy(gtkWidget);
		setStruct(null);
	}

	//get the addOnDestroy from ObjectGtk
	alias ObjectGtk.addOnDestroy addOnDestroy;
code: end
outFile: Widget

file: GtkIMContext.html
struct: GtkIMContext
class: IMContext
prefix: gtk_im_context_
prefix: gtk_
import: glib.Str
import: gdk.Window
structWrap: GdkWindow* Window
#import: gtk.EventKey
#structWrap: GdkEventKey* EventKey
import: gdk.Rectangle
structWrap: GdkRectangle* Rectangle

out: gtk_im_context_get_preedit_string str
out: gtk_im_context_get_preedit_string attrs
out: gtk_im_context_get_preedit_string cursor_pos
out: gtk_im_context_get_surrounding text
out: gtk_im_context_get_surrounding cursor_index


outFile: IMContext

###########################################################
### Cross-process Embedding ###############################
###########################################################

file: GtkPlug.html
struct: GtkPlug
class: Plug
prefix: gtk_plug_
prefix: gtk_
import: gdk.Display
structWrap: GdkDisplay* Display
outFile: Plug

file: GtkSocket.html
struct: GtkSocket
class: Socket
prefix: gtk_socket_
prefix: gtk_
import: gdk.Window
structWrap: GdkWindow* Window
outFile: Socket

###########################################################
### Special-purpose features ##############################
###########################################################

file: GtkCurve.html
struct: GtkCurve
class: Curve
prefix: gtk_curve_
prefix: gtk_
array: gtk_curve_get_vector vector veclen
array: gtk_curve_set_vector vector veclen
outFile: Curve

file: GtkGammaCurve.html
struct: GtkGammaCurve
class: GammaCurve
prefix: gtk_gamma_curve_
prefix: gtk_
outFile: GammaCurve

file: GtkRuler.html
struct: GtkRuler
class: Ruler
implements: OrientableIF
prefix: gtk_ruler_
prefix: gtk_

#imports for Orientable Interface.
import: gtk.OrientableIF
import: gtk.OrientableT

out: gtk_ruler_get_range lower
out: gtk_ruler_get_range upper
out: gtk_ruler_get_range position
out: gtk_ruler_get_range max_size

code: start
	// add the Orientable capabilities
	mixin OrientableT!(GtkRuler);
code: end
outFile: Ruler

file: GtkHRuler.html
struct: GtkHRuler
class: HRuler
prefix: gtk_hruler_
prefix: gtk_
outFile: HRuler

file: GtkVRuler.html
struct: GtkVRuler
class: VRuler
prefix: gtk_vruler_
prefix: gtk_
outFile: VRuler

###########################################################
### Recently Used Documents ###############################
###########################################################

file: GtkRecentManager.html
struct: GtkRecentManager
class: RecentManager
prefix: gtk_recent_manager_
#prefix: gtk_
noprefix: gtk_recent_info_
import: glib.Str
import: gdk.Screen
structWrap: GdkScreen* Screen
import: gtk.RecentInfo
structWrap: GtkRecentInfo* RecentInfo
structWrap: GtkRecentManager* RecentManager
import: glib.ErrorG
import: glib.GException
import: glib.ListG
structWrap: GList* ListG
outFile: RecentManager

struct: GtkRecentInfo
class: RecentInfo
strictPrefix: Y
nosignal: changed
prefix: gtk_recent_info_
#prefix: gtk_
import: glib.Str
structWrap: GtkRecentInfo* RecentInfo
import: gdk.Pixbuf
structWrap: GdkPixbuf* Pixbuf

out: gtk_recent_info_get_application_info app_exec
out: gtk_recent_info_get_application_info count
out: gtk_recent_info_get_application_info time_
array: gtk_recent_info_get_applications Return length
array: gtk_recent_info_get_groups Return length

outFile: RecentInfo

file: GtkRecentChooser.html
struct: GtkRecentChooser
class: RecentChooserT
template: TStruct
prefix: gtk_recent_chooser_
prefix: gtk_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gtk.RecentInfo
structWrap: GtkRecentInfo* RecentInfo
import: gtk.RecentFilter
structWrap: GtkRecentFilter* RecentFilter
import: glib.ListG
structWrap: GList* ListG
import: glib.ListSG
structWrap: GSList* ListSG
alias: setShowNumbers recentChooserSetShowNumbers
alias: getShowNumbers recentChooserGetShowNumbers
array: gtk_recent_chooser_get_uris Return length
interface: RecentChooserIF
outFile: RecentChooserT

file: GtkRecentChooserDialog.html
struct: GtkRecentChooserDialog
class: RecentChooserDialog
implements: RecentChooserIF
prefix: gtk_recent_chooser_dialog_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.Window
structWrap: GtkWindow* Window
import: gtk.RecentManager
structWrap: GtkRecentManager* RecentManager

#imports for RecentChooser interface
import: gtk.RecentChooserIF
import: gtk.RecentChooserT

nocode: gtk_recent_chooser_dialog_new
nocode: gtk_recent_chooser_dialog_new_for_manager

code: start
	// add the RecentChooser capabilities
	mixin RecentChooserT!(GtkRecentChooserDialog);

	/**
	 * Creates a new GtkRecentChooserDialog with a specified recent manager.
	 * This is useful if you have implemented your own recent manager, or if you
	 * have a customized instance of a GtkRecentManager object.
	 * Since 2.10
	 * Params:
	 *  title =  Title of the dialog, or null
	 *  parent =  Transient parent of the dialog, or null,
	 *  manager =  a GtkRecentManager, or null
	 *  buttonsText = text to go in the buttons
	 *  responses = response ID's for the buttons
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string title, Window parent, RecentManager manager,  string[] buttonsText=null, ResponseType[] responses=null )
	{
		// GtkWidget* gtk_recent_chooser_dialog_new_for_manager  (const gchar *title,  GtkWindow *parent,  GtkRecentManager *manager, const gchar *first_button_text,  ...);
		auto p = gtk_recent_chooser_dialog_new_for_manager(Str.toStringz(title), (parent is null) ? null : parent.getWindowStruct(), (manager is null) ? null : manager.getRecentManagerStruct(), null);
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_recent_chooser_dialog_new_for_manager");
		}
		this(cast(GtkRecentChooserDialog*) p);
		addButtons(buttonsText, responses);
	}

	/**
	 * Creates a new GtkRecentChooserDialog with a specified recent manager.
	 * This is useful if you have implemented your own recent manager, or if you
	 * have a customized instance of a GtkRecentManager object.
	 * Since 2.10
	 * Params:
	 *  title =  Title of the dialog, or null
	 *  parent =  Transient parent of the dialog, or null,
	 *  manager =  a GtkRecentManager, or null
	 *  stockIDs = stockIDs of the buttons
	 *  responses = response ID's for the buttons
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (string title, Window parent, RecentManager manager,  StockID[] stockIDs, ResponseType[] responses=null )
	{
		// GtkWidget* gtk_recent_chooser_dialog_new_for_manager  (const gchar *title,  GtkWindow *parent,  GtkRecentManager *manager, const gchar *first_button_text,  ...);
		auto p = gtk_recent_chooser_dialog_new_for_manager(Str.toStringz(title), (parent is null) ? null : parent.getWindowStruct(), (manager is null) ? null : manager.getRecentManagerStruct(), null);
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_recent_chooser_dialog_new_for_manager");
		}
		this(cast(GtkRecentChooserDialog*) p);
		addButtons(stockIDs, responses);
	}
code: end
outFile: RecentChooserDialog

file: GtkRecentChooserMenu.html
struct: GtkRecentChooserMenu
class: RecentChooserMenu
implements: ActivatableIF
implements: RecentChooserIF
prefix: gtk_recent_chooser_menu_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.RecentManager
structWrap: GtkRecentManager* RecentManager

# imports for Activatable Interface
import: gtk.ActivatableT
import: gtk.ActivatableIF

#imports for RecentChooser interface
import: gtk.RecentChooserIF
import: gtk.RecentChooserT

code: start
	// add the Activatable capabilities
	mixin ActivatableT!(GtkRecentChooserMenu);

	// add the RecentChooser capabilities
	mixin RecentChooserT!(GtkRecentChooserMenu);
code: end
outFile: RecentChooserMenu

file: GtkRecentChooserWidget.html
struct: GtkRecentChooserWidget
class: RecentChooserWidget
implements: RecentChooserIF
prefix: gtk_recent_chooser_widget_
prefix: gtk_
import: gtk.Widget
structWrap: GtkWidget* Widget
import: gtk.RecentManager
structWrap: GtkRecentManager* RecentManager

#imports for RecentChooser interface
import: gtk.RecentChooserIF
import: gtk.RecentChooserT

code: start
	// add the RecentChooser capabilities
	mixin RecentChooserT!(GtkRecentChooserWidget);
code: end
outFile: RecentChooserWidget

file: GtkRecentFilter.html
struct: GtkRecentFilter
class: RecentFilter
prefix: gtk_recent_filter_
prefix: gtk_
import: glib.Str
outFile: RecentFilter

###########################################################
### Interface builder #####################################
###########################################################

file: GtkBuildable.html
struct: GtkBuildable
class: BuildableT
template: TStruct
prefix: gtk_buildable_
prefix: gtk_
import: glib.Str
import: gobject.ObjectG
structWrap: GObject* ObjectG
import: gobject.Value
structWrap: GValue* Value
import: gtk.Builder
structWrap: GtkBuilder* Builder
#import: glib.MarkupParser
#structWrap: GMarkupParser* MarkupParser

alias: setName buildableSetName
alias: getName buildableGetName

interface: BuildableIF
outFile: BuildableT

file: GtkBuilder.html
struct: GtkBuilder
class: Builder
prefix: gtk_builder_
prefix: gtk_
import: glib.ErrorG
import: glib.GException
import: glib.ListSG
import: glib.Str
import: gobject.ObjectG
import: gobject.ParamSpec
import: gobject.Value
import: std.string
import: gtkc.glib;
structWrap: GObject* ObjectG
structWrap: GParamSpec* ParamSpec
structWrap: GSList* ListSG
structWrap: GValue* Value

nocode: gtk_builder_get_object
nocode: gtk_builder_get_objects

#imports for gtk_builder_real_get_type_from_name_override
import: gtkc.gobject
import: gtkc.paths
import: glib.Module
import: gobject.Type

array: gtk_builder_add_objects_from_file object_ids
array: gtk_builder_add_objects_from_string object_ids

nocode: gtk_builder_new
code: start
	private struct GtkBuilderClass
	{
		GObjectClass parentClass;
		extern(C) GType function( GtkBuilder*, char* ) get_type_from_name;
		
		/* Padding for future expansion */
		extern(C) void  function()  _gtk_reserved1;
		extern(C) void  function()  _gtk_reserved2;
		extern(C) void  function()  _gtk_reserved3;
		extern(C) void  function()  _gtk_reserved4;
		extern(C) void  function()  _gtk_reserved5;
		extern(C) void  function()  _gtk_reserved6;
		extern(C) void  function()  _gtk_reserved7;
		extern(C) void  function()  _gtk_reserved8;
	}

	/**
	 * Creates a new builder object.
	 * Since 2.12
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this ()
	{
		// GtkBuilder* gtk_builder_new (void);
		auto p = gtk_builder_new();
		if(p is null)
		{
			throw new ConstructionException("null returned by gtk_builder_new()");
		}
		this(cast(GtkBuilder*) p);

		GtkBuilderClass* klass = Type.getInstanceClass!(GtkBuilderClass)( this );
		klass.get_type_from_name = &gtk_builder_real_get_type_from_name_override;
	}

	/**
	 * This function is a modification of _gtk_builder_resolve_type_lazily from "gtk/gtkbuilder.c".
	 * It is needed because it assumes we are linking at compile time to the gtk libs.
	 * specifically the NULL in g_module_open( NULL, 0 );
	 * It replaces the default function pointer "get_type_from_name" in GtkBuilderClass.
	 */
	extern(C) private static GType gtk_builder_real_get_type_from_name_override ( GtkBuilder* builder, char *name )
	{
		GType gtype;
		gtype = g_type_from_name( name );
		if (gtype != GType.INVALID)
		{
			return gtype;
		}
		
		/*
		 * Try to map a type name to a _get_type function
		 * and call it, eg:
		 *
		 * GtkWindow -> gtk_window_get_type
		 * GtkHBox -> gtk_hbox_get_type
		 * GtkUIManager -> gtk_ui_manager_get_type
		 *
		 */
		char   c;
		string symbol_name;

		for (int i = 0; name[i] != '\0'; i++)
		{
			c = name[i];
			/* skip if uppercase, first or previous is uppercase */
			if ((c == Str.asciiToupper (c) &&
			   i > 0 && name[i-1] != Str.asciiToupper (name[i-1])) ||
			  (i > 2 && name[i]   == Str.asciiToupper (name[i]) &&
			   name[i-1] == Str.asciiToupper (name[i-1]) &&
			   name[i-2] == Str.asciiToupper (name[i-2]))
			   )

			symbol_name ~= '_';
			symbol_name ~= Str.asciiTolower (c);
		}
		symbol_name ~=  "_get_type" ;

		/* scan linked librarys for function symbol */
		foreach ( lib; importLibs )
		{
			GType function() func;
			Module mod = Module.open( libPath ~ lib, GModuleFlags.BIND_LAZY );
			if( mod is null )
				continue;
			
			scope(exit) mod.close();

			if ( mod.symbol( symbol_name, cast(void**) &func ) ) {
				return func();
			}
		}

		return GType.INVALID;
	}

	/**
	 * Gets the object named name. Note that this function does not
	 * increment the reference count of the returned object.
	 * Since 2.12
	 * Params:
	 * name = name of object to get
	 * Returns: the object named name or NULL if it could not be found in the object tree.. transfer none.
	 */
	public ObjectG getObject(string name)
	{
		// GObject* gtk_builder_get_object (GtkBuilder *builder,  const gchar *name);
		return newFromObject( gtk_builder_get_object(gtkBuilder, Str.toStringz(name)) );
	}

	/**
	 * Gets all objects that have been constructed by builder.
	 * Since 2.12
	 * Returns: an array containing all the objects constructed by the GtkBuilder instance.
	 */
	public ObjectG[] getObjects()
	{
		ObjectG[] objects;

		// GSList* gtk_builder_get_objects (GtkBuilder *builder);
		GSList* list = gtk_builder_get_objects(gtkBuilder);

		while ( list.next !is null )
		{
			objects ~= newFromObject( cast(GObject*)list.data );
			list = list.next;
		}

		g_slist_free(list);

		return objects;
	}

	/**
	 * This function creates an D object corresponding to the Struct pointer passed in.
	 */
	public ObjectG newFromObject(GObject* cobj)
	{
		version(LDC)
		{
			version(D_Version2)
			{
				alias ClassInfo.find findClassInfo;
			}
		}
		else
		{
			alias ClassInfo.find findClassInfo;
		}

		if(cobj is null)
		{
			return null;
		}

		void* dObj = g_object_get_data(cobj, Str.toStringz("GObject"));

		if ( dObj !is null )
		{
			return cast(ObjectG)dObj;
		}

		string type = convertClassName(Type.name((cast(GTypeInstance*)cobj).gClass.gType));
		ClassInfo ci = cast(ClassInfo)findClassInfo(type);

		//Gobject and Gio types both start with g, so try both.
		if(ci is null && startsWith(type, "gobject"))
		{
				ci = cast(ClassInfo)findClassInfo("gio"~ type[7..$]);
		}

		if(ci is null)
		{
			return null;
		}

		ObjectG obj = cast(ObjectG)gtkc.gtktypes._d_newclass(ci);

		version(D_Version2)
		{
			obj.__ctor(cobj);
		}
		else
		{
			obj._ctor(cobj);
		}

		return obj;
	}

	/**
	 * Turn the name of a C Type in to the name of the corresponding D type.
	 * Note: If the prefix of the type is "G" this always usses "gobject" as
	 *     the prefix, extra care should be taken for types from GIO.
	 */
	private string convertClassName(string gName)
	{
		string conv;
		string prefix;

		version(Tango)
		{
			alias toUpper toupper;
			alias toLower tolower;
		}
		version(D_Version2)
		{
			alias toUpper toupper;
			alias toLower tolower;
		}

		if      ( startsWith(gName, "GtkSource" ) ) prefix = "Gsv";
		else if ( startsWith(gName, "Gtk") )        prefix = "Gtk";
		else if ( startsWith(gName, "Gdk") )        prefix = "Gdk";
		else if ( startsWith(gName, "Gst") )        prefix = "Gst";
		else if ( startsWith(gName, "Gda") )        prefix = "Gda";
		else if ( startsWith(gName, "Atk") )        prefix = "Atk";
		else if ( startsWith(gName, "G") )          prefix = "G";
		else if ( startsWith(gName, "Pango") )      prefix = "Pg";
		else if ( startsWith(gName, "cairo") )      prefix = "cairo";

		conv = gName[prefix.length..gName.length];

		if ( conv == "Object" ) conv ~= prefix;
		if ( prefix == "Pg" )   conv = "Pg" ~ gName[5..gName.length];
		if ( prefix == "cairo") conv = toupper(gName[6..7]) ~ gName[7..gName.length - 2];

		prefix = tolower(prefix);

		if( prefix == "gst") prefix = "gstreamer";
		if( prefix == "g")   prefix = "gobject";
		if( prefix == "pg" ) prefix = "pango";

		return prefix ~"."~ conv ~"."~ conv;
	}

	private bool startsWith(string str, string prefix)
	{
		return str.length >= prefix.length && str[0..prefix.length] == prefix;
	}

	version(LDC)
	{
		//version( !D_Version2 )
		version(D_Version2) {} else
		{
			private Object _d_newclass(ClassInfo ci)
			{
				void* p = cast(void*)_d_allocclass(ci);
				(cast(byte*) p)[0 .. ci.init.length] = ci.init[];
			
				return cast(Object) p;
			}

			private ClassInfo findClassInfo(string classname)
			{
				foreach ( m; ModuleInfo )
				{
					foreach ( c; m.localClasses )
					{
						if ( c.name == classname )
						return c;
					}
				}

				return null;
			}
		}
	}
code: end
outFile: Builder

###########################################################
### Deprecated ############################################
###########################################################

#file: GtkCList.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkCTree.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkCombo.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

file: GtkFileSelection.html
struct: GtkFileSelection
class: FileSelection
prefix: gtk_file_selection_
prefix: gtk_
import: glib.Str
outFile: FileSelection

file: GtkItemFactory.html
struct: GtkItemFactory
class: ItemFactory
prefix: gtk_item_factory_
prefix: gtk_
noprefix: gtk_item_factory_create_menu_entries
import: glib.Str
import: gtk.AccelGroup
structWrap: GtkAccelGroup* AccelGroup
import: gtk.Widget
structWrap: GtkWidget* Widget
structWrap: GtkItemFactory* ItemFactory
#import: gtk.ItemFactoryEntry
#structWrap: GtkItemFactoryEntry* ItemFactoryEntry
outFile: ItemFactory

#file: GtkList.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkListItem.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkOldEditable.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkOptionMenu.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkPixmap.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkPreview.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkText.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

file: GtkTooltips.html
struct: GtkTooltips
class: Tooltips
prefix: gtk_tooltips_
prefix: gtk_
import: glib.Str
import: gtk.Widget
structWrap: GtkWidget* Widget
#import: gtk.TooltipsData
#structWrap: GtkTooltipsData* TooltipsData
import: gtk.Window
structWrap: GtkWindow* Window

out: gtk_tooltips_get_info_from_tip_window tooltips
out: gtk_tooltips_get_info_from_tip_window current_widget

outFile: Tooltips

#file: gtkTipsQuery.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkTree.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

#file: GtkTreeItem.html
#struct: 
#class: 
#prefix: 
#prefix: gtk_
#outFile: 

file: GtkProgress.html
struct: GtkProgress
class: Progress
prefix: gtk_progress_
prefix: gtk_
import: glib.Str
import: gtk.Adjustment
structWrap: GtkAdjustment* Adjustment
outFile: Progress
